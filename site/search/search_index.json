{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<ul> <li> Vision</li> <li> Business Requirements</li> <li> Problem Statement</li> <li> Implementation Roadmap</li> </ul>"},{"location":"#implementation-specs","title":"Implementation Specs","text":"<ul> <li> Module Index</li> <li> UI-CODEGEN \u2014 Phase 1 PRD</li> <li> UI-CODEGEN \u2014 Phase 1 TRD</li> <li> JIRA-CLIENT \u2014 Phase 1 PRD</li> <li> JIRA-CLIENT \u2014 Phase 1 TRD</li> <li> DATA-LAYER \u2014 Phase 1 PRD</li> <li> DATA-LAYER \u2014 Phase 1 TRD</li> <li> APP-APIS \u2014 Phase 1 PRD</li> <li> APP-APIS \u2014 Phase 1 TRD</li> <li> USER-INTERFACE \u2014 Phase 1 PRD</li> <li> USER-INTERFACE \u2014 Phase 1 TRD</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/","title":"Release Progress and Hierarchical Delivery Visibility Platform","text":""},{"location":"Project_Analysis_BRD_Phase1.docx/#1-business-context","title":"1. Business Context","text":"<p>Project Managers must track and communicate product growth progress across multiple releases. While Stories are linked to Epics in the work management tool, both Epics and Stories often span across releases, making it difficult to understand what is targeted for a specific release, what is completed, and what is delayed. Current reporting is manual, inconsistent, and lacks a clear hierarchical view, including associated bugs and tasks.</p>"},{"location":"Project_Analysis_BRD_Phase1.docx/#pain-points-observed","title":"Pain points observed:","text":"<ul> <li>No single hierarchical view of Epics and Stories targeted for a release  </li> <li>Stories spanning multiple releases make progress reporting messy and error-prone  </li> <li>Open bugs and tasks linked to stories are not visible in release progress views  </li> <li>Delays are tracked informally and timeline shift impacts are not surfaced early  </li> <li>Publishing release progress requires manual consolidation into presentations or emails</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/#2-business-problem","title":"2. Business Problem","text":"<p>Release progress is not visible in a structured, hierarchical, and predictive way, causing blind spots in what is targeted for each release, how delivery is progressing, where bugs and tasks are accumulating, and how delays impact future work.</p> <p>3. Objective / Desired Outcomes</p> <ul> <li>Provide a hierarchical release view that clearly shows Epics and their Stories targeted for a release  </li> <li>Show progress status at Epic and Story levels, including completion and remaining scope  </li> <li>Surface open bugs (by priority) and open tasks linked to each Story  </li> <li>Highlight delay against each Story and infer a potential timeline shift for future Stories  </li> <li>Enable Project Managers to publish a clear release progress report with minimal manual effort</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/#4-target-users","title":"4. Target Users","text":""},{"location":"Project_Analysis_BRD_Phase1.docx/#primary-users-must-serve","title":"Primary users (must-serve):","text":"<ul> <li>Project Managers  </li> <li>Delivery Managers or Engineering Managers responsible for release tracking</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/#secondary-users-nice-to-serve","title":"Secondary users (nice-to-serve):","text":"<ul> <li>Product Owners and Product Managers  </li> <li>Leadership stakeholders consuming release updates</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/#5-success-criteria","title":"5. Success Criteria","text":"<ul> <li>A Project Manager can select a release and view Epics and Stories targeted for it in a hierarchical structure  </li> <li>Progress is visible at Epic and Story levels with clear counts and states  </li> <li>Open bugs and tasks linked to Stories are visible by priority and status  </li> <li>Delayed Stories are highlighted with an estimated impact on future timelines  </li> <li>Release progress can be exported or shared as a report without manual consolidation</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/#6-guardrails-must-haves","title":"6. Guardrails (Must-Haves)","text":""},{"location":"Project_Analysis_BRD_Phase1.docx/#61-data-sources","title":"6.1 Data Sources","text":"<ul> <li>Must integrate with the work management platform (for example, Jira) via public APIs.  </li> <li>Must pull Epics, Stories, Bugs, Tasks, priorities, assignees, and status history.  </li> <li>Must support release identification through a standard field (for example, fixVersion or release label).</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/#62-scope","title":"6.2 Scope","text":"<ul> <li>Scope is limited to release-level hierarchical visibility and progress reporting.  </li> <li>Timeline shift is an indicative projection based on observed delays; complex forecasting models are not required in Phase 1.</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/#63-mandatory-business-dimensions","title":"6.3 Mandatory Business Dimensions","text":"<p>The solution must cover these dimensions:</p> <ul> <li>Release Scoping Visibility \u2014 show what Epics and Stories belong to a selected release, even when spanning multiple releases.  </li> <li>Hierarchical Progress \u2014 display Epic \u2192 Story hierarchy with counts and completion status.  </li> <li>Quality and Workload Signals \u2014 show open Bugs by priority and open Tasks linked to each Story.  </li> <li>Delay and Impact Awareness \u2014 highlight delayed Stories and infer potential timeline shift for remaining Stories.  </li> <li>Report Publishing \u2014 allow generation, export, or sharing of a release progress report.</li> </ul> <p>Important: This business requirement document does not define exact screens or calculations. Each team\u2019s Product Owner must define the final product specification.</p>"},{"location":"Project_Analysis_BRD_Phase1.docx/#64-product-owner-ownership-requirement","title":"6.4 Product Owner Ownership Requirement","text":"<p>Each team\u2019s Product Owner must:</p> <ul> <li>Define the minimum viable hierarchical views and drill-down flows  </li> <li>Define assumptions for identifying release membership and spanning items  </li> <li>Define delay highlighting logic and timeline shift estimation approach  </li> <li>Specify scope cuts required for hackathon duration</li> </ul>"},{"location":"Project_Analysis_BRD_Phase1.docx/#7-out-of-scope-non-goals","title":"7. Out of Scope (Non-Goals)","text":"<ul> <li>Organization-wide productivity benchmarking  </li> <li>Automated notifications or reminder workflows  </li> <li>Complex predictive scheduling models beyond simple timeline shift indication  </li> <li>Financial or resource capacity planning</li> </ul>"},{"location":"business-requirements/","title":"Business &amp; Functional Requirements","text":""},{"location":"business-requirements/#1-purpose","title":"1. Purpose","text":"<p>This document defines the detailed business and functional requirements for HALDI (Hierarchical Agile Leadership Dashboard Initiative), a release progress visibility platform that provides unified Epic-Story hierarchical views, quality signals, and timeline impact awareness for project managers and delivery teams.</p>"},{"location":"business-requirements/#2-scope","title":"2. Scope","text":"<ul> <li> <p>In-Scope:</p> <ul> <li>Hierarchical release view showing Epic \u2192 Story relationships for selected releases</li> <li>Progress tracking at Epic and Story levels with completion states and counts</li> <li>Quality signals including open bugs by priority linked to Stories</li> <li>Workload signals including open tasks by status linked to Stories  </li> <li>Delay detection and indicative timeline shift impact for remaining work</li> <li>Report generation and export functionality for release progress updates</li> <li>Edge case handling for spanning Epics, multi-linked Stories, and orphaned items</li> </ul> </li> <li> <p>Out-of-Scope:</p> <ul> <li>Organization-wide productivity benchmarking and cross-team analytics</li> <li>Automated notifications, reminders, or workflow triggers</li> <li>Complex predictive scheduling models beyond simple timeline shift indication</li> <li>Financial planning, resource capacity modeling, or budget tracking</li> <li>Real-time collaboration features or commenting systems</li> </ul> </li> </ul>"},{"location":"business-requirements/#3-stakeholders","title":"3. Stakeholders","text":"<ul> <li>Primary: Project Managers, Delivery Managers, Engineering Managers</li> <li>Secondary: Product Owners, Product Managers, Leadership Stakeholders consuming release updates</li> </ul>"},{"location":"business-requirements/#4-key-use-cases","title":"4. Key Use Cases","text":""},{"location":"business-requirements/#use-case-uc-001-view-release-hierarchy","title":"Use Case UC-001: View Release Hierarchy","text":"<p>Description: Project Manager selects a release and views all associated Epics and Stories in hierarchical structure. Actors: Project Manager, Delivery Manager Preconditions: Release data exists in work management system with proper Epic-Story linkages. Main Flow: </p> <pre><code>flowchart TD\n    A[PM selects target release] --&gt; B[System queries work management API]\n    B --&gt; C[System identifies Epics by release membership]\n    C --&gt; D[System fetches linked Stories for each Epic]\n    D --&gt; E[System handles spanning Epics/Stories]\n    E --&gt; F[System renders hierarchical view]\n    F --&gt; G[PM reviews Epic \u2192 Story structure]\n    G --&gt; H{Edge cases present?}\n    H --&gt;|Yes| I[System shows spanning indicators]\n    H --&gt;|No| J[Display complete hierarchy]\n    I --&gt; K[PM drills down for details]\n    J --&gt; K\n    K --&gt; L[PM validates scope accuracy]\n\n    %% Error flows\n    B --&gt; M[API Error]\n    M --&gt; N[Display error message]\n    C --&gt; O[No Epics found]\n    O --&gt; P[Display empty state]\n    D --&gt; Q[Stories without Epic links]\n    Q --&gt; R[Show in Unlinked section]\n\n    classDef user fill:#DFF,stroke:#00F\n    classDef system fill:#FFD,stroke:#F90\n    classDef error fill:#FDD,stroke:#F00\n\n    class A,G,K,L user\n    class B,C,D,E,F,I,J system\n    class M,N,O,P,Q,R error</code></pre> <p>Alternate Flows: - Epic spans multiple releases: Show Epic with subset of Stories relevant to selected release - Story linked to multiple Epics: Display under primary Epic with secondary association indicators - Orphaned Stories: Display in separate \"Unlinked Stories\" section with release membership - No release data: Display empty state with guidance for data setup</p>"},{"location":"business-requirements/#use-case-uc-002-track-progress-and-quality-signals","title":"Use Case UC-002: Track Progress and Quality Signals","text":"<p>Description: View progress status and quality indicators for Epics and Stories within a release. Actors: Project Manager, Delivery Manager Preconditions: Release hierarchy loaded successfully with work items. Main Flow:</p> <pre><code>flowchart TD\n    A[PM views loaded release hierarchy] --&gt; B[System calculates Epic progress]\n    B --&gt; C[System aggregates Story completion counts]\n    C --&gt; D[System fetches linked bugs by priority]\n    D --&gt; E[System fetches linked tasks by status]\n    E --&gt; F[System renders progress indicators]\n    F --&gt; G[System displays quality signals]\n    G --&gt; H[PM reviews progress vs scope]\n    H --&gt; I{Quality issues detected?}\n    I --&gt;|Yes| J[PM investigates P1/P2 bugs]\n    I --&gt;|No| K[PM confirms progress accuracy]\n    J --&gt; L[PM escalates critical issues]\n    K --&gt; M[PM proceeds with planning]\n    L --&gt; M\n\n    %% Alternate flows\n    B --&gt; N[Stories in unknown status]\n    N --&gt; O[Mark as \"Needs Review\"]\n    D --&gt; P[Bug priority not set]\n    P --&gt; Q[Display as \"Unclassified\"]\n\n    classDef user fill:#DFF,stroke:#00F\n    classDef system fill:#FFD,stroke:#F90\n    classDef warning fill:#FFA,stroke:#FA0\n\n    class A,H,J,K,L,M user\n    class B,C,D,E,F,G system\n    class N,O,P,Q warning</code></pre> <p>Alternate Flows: - Missing status information: Display items as \"Needs Review\" with indicators - Bugs without priority classification: Show as \"Unclassified\" in separate section - Tasks without clear status: Group under \"Status Unknown\" for PM attention - Performance issues with large datasets: Implement pagination or progressive loading</p>"},{"location":"business-requirements/#use-case-uc-003-detect-delays-and-timeline-impact","title":"Use Case UC-003: Detect Delays and Timeline Impact","text":"<p>Description: Identify delayed Stories and assess indicative timeline shift for remaining work. Actors: Project Manager, Delivery Manager Preconditions: Stories have due dates or sprint assignments, status history available. Main Flow:</p> <pre><code>flowchart TD\n    A[PM requests delay analysis] --&gt; B[System analyzes Story due dates]\n    B --&gt; C[System compares against current status]\n    C --&gt; D[System identifies overdue Stories]\n    D --&gt; E[System calculates delay impact]\n    E --&gt; F[System estimates timeline shift]\n    F --&gt; G[System highlights delayed items]\n    G --&gt; H[PM reviews delay indicators]\n    H --&gt; I{Critical delays found?}\n    I --&gt;|Yes| J[PM assesses impact scope]\n    I --&gt;|No| K[PM confirms timeline on track]\n    J --&gt; L[PM updates stakeholders]\n    K --&gt; M[PM proceeds with current plan]\n    L --&gt; M\n\n    %% Edge cases\n    B --&gt; N[No due dates set]\n    N --&gt; O[Use sprint-based estimation]\n    C --&gt; P[Inconsistent status history]\n    P --&gt; Q[Flag for manual review]\n\n    classDef user fill:#DFF,stroke:#00F\n    classDef system fill:#FFD,stroke:#F90\n    classDef critical fill:#FDD,stroke:#F00\n\n    class A,H,J,K,L,M user\n    class B,C,D,E,F,G,O system\n    class N,P,Q critical</code></pre> <p>Alternate Flows: - No due dates configured: Use sprint boundaries for delay calculation - Inconsistent status transitions: Flag items for manual PM review - External dependencies causing delays: Surface dependency indicators - Scope changes affecting timeline: Distinguish between delay and scope adjustment</p>"},{"location":"business-requirements/#4b-secondary-use-cases","title":"4b. Secondary Use Cases","text":""},{"location":"business-requirements/#use-case-uc-004-generate-release-report","title":"Use Case UC-004: Generate Release Report","text":"<p>Description: Export or share a comprehensive release progress report. Actors: Project Manager Preconditions: Release data loaded and validated by PM. Main Flow:</p> <pre><code>flowchart TD\n    A[PM initiates report generation] --&gt; B[System compiles hierarchy data]\n    B --&gt; C[System adds progress metrics]\n    C --&gt; D[System includes quality signals]\n    D --&gt; E[System adds delay analysis]\n    E --&gt; F[System formats report template]\n    F --&gt; G{Export format choice}\n    G --&gt;|PDF| H[Generate PDF report]\n    G --&gt;|Markdown| I[Generate MD file]\n    G --&gt;|Link| J[Create shareable link]\n    H --&gt; K[PM downloads report]\n    I --&gt; L[PM accesses file]\n    J --&gt; M[PM shares link]\n    K --&gt; N[PM distributes to stakeholders]\n    L --&gt; N\n    M --&gt; N\n\n    classDef user fill:#DFF,stroke:#00F\n    classDef system fill:#FFD,stroke:#F90\n\n    class A,K,L,M,N user\n    class B,C,D,E,F,H,I,J system</code></pre> <p>Alternate Flows: - Large dataset export: Implement chunked generation with progress indicator - Template customization: Allow basic formatting preferences - Export failures: Provide retry mechanism and error details - Scheduled exports: Support recurring report generation (future enhancement)</p>"},{"location":"business-requirements/#5-functional-requirements","title":"5. Functional Requirements","text":"<ol> <li>FR-001: System shall connect to work management platform APIs (Jira) to fetch Epics, Stories, Bugs, and Tasks.</li> <li>FR-002: System shall identify release membership through fixVersion or release label fields.</li> <li>FR-003: System shall display Epic \u2192 Story hierarchy for selected release with visual nesting.</li> <li>FR-004: System shall handle Epics spanning multiple releases by showing relevant Stories only.</li> <li>FR-005: System shall display Stories linked to multiple Epics under primary Epic with secondary indicators.</li> <li>FR-006: System shall calculate and display Epic progress based on Story completion counts.</li> <li>FR-007: System shall show Story-level progress with status indicators (To Do, In Progress, Done).</li> <li>FR-008: System shall display open bugs linked to Stories grouped by priority (P1, P2, P3).</li> <li>FR-009: System shall show open tasks linked to Stories with current status.</li> <li>FR-010: System shall identify delayed Stories by comparing due dates to current status.</li> <li>FR-011: System shall calculate indicative timeline shift for remaining Stories based on delays.</li> <li>FR-012: System shall highlight delayed items with visual indicators and impact assessment.</li> <li>FR-013: System shall generate exportable reports in PDF, Markdown, and shareable link formats.</li> <li>FR-014: System shall provide empty state guidance when no release data is available.</li> <li>FR-015: System shall handle API errors gracefully with user-friendly error messages.</li> <li>FR-016: System shall display release KPIs: overall completion, epics completed, stories on track, open bugs, open tasks, delayed items.</li> <li>FR-017: System shall render summary graphs for Epics, Stories, and Tasks across status categories: Completed, Delayed, In Progress, Not Started.</li> <li>FR-018: System shall include a scheduler job that pulls Jira API data into the application database at specified intervals.</li> <li>FR-019: System shall provide an API endpoint to manually trigger the scheduler job on demand.</li> </ol>"},{"location":"business-requirements/#6-acceptance-criteria","title":"6. Acceptance Criteria","text":"<p>FR-001 / UC-001: - AC1: System successfully authenticates with Jira API using provided credentials - AC2: System retrieves Epic, Story, Bug, and Task data within 10 seconds for typical releases - AC3: API errors display specific error messages with retry options</p> <p>FR-003 / UC-001: - AC1: Epic names display as expandable sections with Story count indicators - AC2: Stories appear indented under their parent Epics with clear visual hierarchy - AC3: Hierarchy remains consistent across browser refresh and navigation</p> <p>FR-004, FR-005 / UC-001: - AC1: Spanning Epics show \"(Partial)\" indicator with tooltip explaining scope - AC2: Multi-linked Stories display primary Epic association with \"Also in: Epic-X\" notation</p> <p>FR-006, FR-007 / UC-002: - AC1: Epic progress shows \"X of Y Stories complete\" with percentage and progress bar - AC2: Story status uses color coding: Red (To Do), Yellow (In Progress), Green (Done) - AC3: Progress calculations update within 5 seconds of underlying data changes</p> <p>FR-008, FR-009 / UC-002: - AC1: Bugs display with priority badges (P1: Red, P2: Orange, P3: Yellow) and count - AC2: Tasks show status with standard workflow states and assignee information - AC3: Quality signals expand on click to show detailed bug/task listings</p> <p>FR-010, FR-011, FR-012 / UC-003: - AC1: Delayed Stories show red warning icon with days overdue count - AC2: Timeline shift displays as \"+X days impact\" with affected Story count - AC3: Delay analysis updates daily and shows calculation methodology on hover</p> <p>FR-013 / UC-004: - AC1: PDF export generates within 30 seconds and includes all hierarchy, progress, and delay data - AC2: Markdown export creates properly formatted file with tables and section headers - AC3: Shareable links remain accessible for 30 days with view-only permissions</p> <p>FR-016 / UC-002: - AC1: KPIs display includes overall completion, epics completed, stories on track, open bugs, open tasks, delayed items. - AC2: KPI values update within 5 seconds after underlying data changes. - AC3: KPI tiles/tooltips show calculation definitions for transparency.</p> <p>FR-017 / UC-002: - AC1: Summary graphs render status breakdowns for Epics, Stories, and Tasks across Completed, Delayed, In Progress, Not Started. - AC2: Graphs support at least bar and donut views; default to bar. - AC3: Graphs load within 3 seconds for up to 2,000 items and refresh in place without full page reload.</p> <p>FR-018: - AC1: Scheduler interval is configurable (e.g., cron expression) with default every 15 minutes. - AC2: Each run is idempotent: re-fetches only changed issues since last successful run (via <code>updated</code> timestamp or changelog). - AC3: Retries with exponential backoff on transient Jira/API/network errors; maximum 3 retries per batch. - AC4: Writes are atomic per batch and produce audit logs containing run ID, start/end time, item counts, successes/failures. - AC5: Respect Jira rate limits and paginate (<code>maxResults</code>, <code>startAt</code>) without exceeding quotas.</p> <p>FR-019: - AC1: Protected API endpoint requires authentication and appropriate role (e.g., Admin) to trigger the scheduler. - AC2: Manual trigger enqueues a job immediately and returns a run ID for tracking. - AC3: Endpoint supports a \"dry-run\" mode that reports the would-be changes without persisting. - AC4: Concurrent run protection: if a job is already running, manual trigger either queues or returns a clear conflict response.</p>"},{"location":"business-requirements/#7-non-functional-requirements","title":"7. Non-Functional Requirements","text":"<ul> <li>Performance: API responses complete within 10 seconds for releases with up to 50 Epics</li> <li>Security: API credentials stored securely, shareable links expire after 30 days</li> <li>Reliability: System maintains 99% uptime during business hours with graceful degradation</li> <li>Usability: Interface loads and renders hierarchy within 3 seconds on standard browsers</li> <li>Compatibility: Supports Jira Cloud API v3, extensible for other work management platforms</li> </ul>"},{"location":"business-requirements/#8-data-models-entities","title":"8. Data Models &amp; Entities","text":"<p>On hold pending validation of Jira API responses. This section will be finalized after inspecting actual payloads (fields, relationships, pagination and filtering behavior). For now: - Placeholder: Entities likely include Release, Epic, Story, Bug, Task with associations via fixVersion/labels and issue links. - Action: Capture real response samples and update class diagram accordingly.</p>"},{"location":"business-requirements/#next-steps-jira-api-response-sampling","title":"Next Steps: Jira API Response Sampling","text":"<ul> <li>Endpoints to sample:<ul> <li><code>GET /rest/api/3/search</code> (JQL for releases via <code>fixVersion</code> and labels)</li> <li><code>GET /rest/api/3/issue/{issueIdOrKey}</code> (detail for Epic/Story/Bug/Task)</li> <li><code>GET /rest/api/3/project/{projectIdOrKey}/versions</code> (release versions metadata)</li> <li><code>GET /rest/api/3/issue/{issueIdOrKey}/changelog</code> (status history for delay analysis)</li> <li><code>GET /rest/api/3/priority</code> (bug priority taxonomy)</li> </ul> </li> <li>Fields to capture:<ul> <li>Core: <code>key</code>, <code>summary</code>, <code>status</code>, <code>issuetype</code>, <code>fixVersion</code>, <code>labels</code>, <code>assignee</code></li> <li>Links: <code>epic link</code> (custom field), <code>issuelinks</code> (dependencies, relates to)</li> <li>Dates: <code>duedate</code>, <code>created</code>, <code>updated</code>, sprint fields (via Agile API if used)</li> <li>Metrics: <code>priority</code> (for bugs), story status categories (To Do/In Progress/Done)</li> </ul> </li> <li>Considerations:<ul> <li>Pagination: <code>maxResults</code>, <code>startAt</code>, total count</li> <li>Rate limits and batching strategy for hierarchy fetches</li> <li>Project-specific custom fields mapping (e.g., Epic Link field ID)</li> </ul> </li> </ul>"},{"location":"business-requirements/#9-business-rules-constraints","title":"9. Business Rules &amp; Constraints","text":"<ul> <li>Rule 1: Epic progress calculated as (completed Stories / total Stories) \u00d7 100</li> <li>Rule 2: Story delay determined when current date &gt; due date and status \u2260 \"Done\"</li> <li>Rule 3: Timeline shift = (average delay per Story) \u00d7 (remaining Stories count)</li> <li>Rule 4: P1 bugs must be visible prominently if open &gt; 3 business days</li> <li>Rule 5: Release membership determined by fixVersion field, fallback to release labels</li> <li>Rule 6: Primary Epic association determined by first Epic link or most recent assignment</li> </ul>"},{"location":"business-requirements/#10-assumptions-dependencies","title":"10. Assumptions &amp; Dependencies","text":"<ul> <li>Assumptions: <ul> <li>Teams maintain current Epic-Story linkages in work management system</li> <li>Due dates are set consistently for timeline analysis accuracy</li> <li>Release membership fields (fixVersion/labels) are populated correctly</li> <li>API rate limits allow for real-time data refresh during business hours</li> </ul> </li> <li>Dependencies: <ul> <li>Jira Cloud API availability and authentication</li> <li>Consistent network connectivity for API calls</li> <li>Work management system data quality and completeness</li> </ul> </li> </ul>"},{"location":"business-requirements/#11-glossary","title":"11. Glossary","text":"<ul> <li>Epic: Large work item that groups related Stories, may span multiple releases</li> <li>Story: Individual deliverable work item that belongs to one or more Epics  </li> <li>Release: Time-boxed delivery milestone containing targeted Epics and Stories</li> <li>fixVersion: Jira field indicating which release(s) an item is targeted for</li> <li>Timeline Shift: Indicative delay impact on remaining work based on current delays</li> <li>Spanning Item: Epic or Story associated with multiple releases</li> <li>Primary Association: Main Epic linkage for Stories with multiple Epic connections</li> </ul>"},{"location":"business-requirements/#12-open-questions","title":"12. Open Questions","text":"<ul> <li>Should the system support custom work management platforms beyond Jira in Phase 1?</li> <li>How should conflicting due dates be resolved when Stories have multiple Epic associations?</li> <li>Should timeline shift calculations include weekends and holidays in delay impact?</li> <li>What level of historical data retention is needed for delay pattern analysis?</li> <li>Should the system cache data locally or always fetch real-time information?</li> </ul>"},{"location":"implementation-roadmap/","title":"Implementation Roadmap","text":""},{"location":"implementation-roadmap/#1-overview","title":"1. Overview","text":"<ul> <li>Purpose: Build sequence for HALDI MVP</li> <li>Approach: Dependency-driven component sequencing</li> <li>Milestones: 3 key deliverable milestones</li> <li>Team Capacity: 2 developers (parallel per milestone)</li> </ul>"},{"location":"implementation-roadmap/#2-components","title":"2. Components","text":""},{"location":"implementation-roadmap/#foundation-components-build-first","title":"Foundation Components (Build First)","text":"<ul> <li>UI-CODEGEN: Generate UI from Figma designs for <code>apps/ui-hk-gamar</code> (base screens, components, routing)</li> <li>JIRA-CLIENT: Secure Jira API consumption (OAuth/API token, rate limits)</li> </ul>"},{"location":"implementation-roadmap/#core-components-build-second","title":"Core Components (Build Second)","text":"<ul> <li>DATA-LAYER: Persistence models + ingestion pipeline (populate DB from Jira)</li> <li>APP-APIS: Backend API (BFF) to read persisted data for UI</li> </ul>"},{"location":"implementation-roadmap/#feature-components-build-third","title":"Feature Components (Build Third)","text":"<ul> <li>USER-INTERFACE: Bind generated UI to APP-APIS, render real data</li> <li>REPORTING: Export Markdown/PDF/Link report (depends on APP-APIS + DATA-LAYER)</li> </ul>"},{"location":"implementation-roadmap/#3-build-sequence","title":"3. Build Sequence","text":"<pre><code>graph TD\n    A[UI-CODEGEN&lt;br&gt;Figma \u2192 UI] --&gt; E[USER-INTERFACE]\n    B[JIRA-CLIENT&lt;br&gt;Consume Jira APIs] --&gt; C[DATA-LAYER&lt;br&gt;Populate DB]\n    C --&gt; D[APP-APIS&lt;br&gt;Fetch for UI]\n    D --&gt; E\n    D --&gt; F[REPORTING]</code></pre>"},{"location":"implementation-roadmap/#4-build-milestones","title":"4. Build Milestones","text":""},{"location":"implementation-roadmap/#milestone-1-foundations-ready","title":"Milestone 1: Foundations Ready","text":"<p>Components: UI-CODEGEN, JIRA-CLIENT What You Get: Base UI scaffold from Figma and secure Jira connectivity Why First: Establish UI shell and external data access Success Criteria: - \u2705 Figma-to-code components integrated in <code>apps/ui-hk-gamar</code> - \u2705 Jira OAuth/API token configured; secrets stored safely - \u2705 Basic Jira fetches verified (Epics, Stories, Bugs, Tasks) - \u2705 Rate-limit/pagination handling patterns established Parallel Work: Dev A \u2192 UI-CODEGEN; Dev B \u2192 JIRA-CLIENT</p>"},{"location":"implementation-roadmap/#milestone-2-data-pipeline-apis","title":"Milestone 2: Data Pipeline + APIs","text":"<p>Components: DATA-LAYER, APP-APIS What You Get: Database populated from Jira and app APIs to serve UI Why Second: UI needs persisted data and stable APIs Success Criteria: - \u2705 Ingestion jobs populate DB entities (Release, Epic, Story, Bug, Task) - \u2705 Data integrity checks; idempotent updates; backoff on rate limits - \u2705 App APIs: <code>/releases</code>, <code>/release/:id/hierarchy</code>, <code>/release/:id/signals</code> - \u2705 Pagination and error surfaces standardized Parallel Work: Dev A \u2192 DATA-LAYER; Dev B \u2192 APP-APIS</p>"},{"location":"implementation-roadmap/#milestone-3-ui-data-binding-reports","title":"Milestone 3: UI Data Binding + Reports","text":"<p>Components: USER-INTERFACE, REPORTING What You Get: Data-driven UI and exportable reports Why Last: Depends on app APIs and persisted data Success Criteria: - \u2705 UI binds to APP-APIS; release selector, hierarchy, signals rendered - \u2705 Edge cases handled: spanning epics, orphan/multi-linked stories - \u2705 Report export: Markdown + PDF + shareable link - \u2705 Basic template customization; retries on export failures Parallel Work: Dev A \u2192 USER-INTERFACE; Dev B \u2192 REPORTING</p>"},{"location":"implementation-roadmap/#5-parallel-development","title":"5. Parallel Development","text":""},{"location":"implementation-roadmap/#what-can-be-built-together","title":"What Can Be Built Together","text":"<ul> <li>Milestone 1: UI-CODEGEN + JIRA-CLIENT</li> <li>Milestone 2: DATA-LAYER + APP-APIS</li> <li>Milestone 3: USER-INTERFACE + REPORTING</li> </ul>"},{"location":"implementation-roadmap/#what-must-be-sequential","title":"What Must Be Sequential","text":"<ul> <li>Foundation \u2192 Core \u2192 Features (milestones do not overlap)</li> </ul>"},{"location":"implementation-roadmap/#6-dependency-notes","title":"6. Dependency Notes","text":"<ul> <li>UI-CODEGEN: Figma-driven components/pages scaffold; keep decoupled from data bindings.</li> <li>JIRA-CLIENT: Secure token/OAuth; pagination, rate-limit backoff; normalized payloads.</li> <li>DATA-LAYER: Schemas + mappers; ingestion jobs; idempotent upserts; audits.</li> <li>APP-APIS: Versioned endpoints for UI; consistent error/pagination contracts.</li> <li>USER-INTERFACE: Bind to APP-APIS; progressive loading; hierarchy-first UX.</li> <li>REPORTING: Deterministic templates; chunked export; link generation.</li> </ul>"},{"location":"implementation-roadmap/#7-milestone-deliverables","title":"7. Milestone Deliverables","text":"<ul> <li>M1 Artifacts: Auth module, Jira client, entity schemas, release membership functions</li> <li>M2 Artifacts: REST endpoints, aggregation services, delay heuristics, unit tests on calculators</li> <li>M3 Artifacts: UI views/components, export templates, PDF/MD generator, link service</li> </ul>"},{"location":"implementation-roadmap/#8-risk-mitigation","title":"8. Risk &amp; Mitigation","text":"<ul> <li>API Rate Limits: Implement caching/backoff; paginate responses</li> <li>Data Hygiene Variability: Fallbacks for labels; empty-state guidance</li> <li>Timeline Heuristics Simplicity: Clearly label as indicative; allow PM overrides (future)</li> </ul>"},{"location":"implementation-roadmap/#9-success-metrics-mvp","title":"9. Success Metrics (MVP)","text":"<ul> <li>\u226595% correct release mapping; \u226590% hierarchical completeness</li> <li>\u22645 minutes to generate/share report; \u226580% manual consolidation reduction</li> <li>\u226590% delayed Stories flagged; 100% bug/task visibility by category</li> </ul>"},{"location":"vision/","title":"Vision","text":""},{"location":"vision/#1-vision-statement","title":"\ud83d\ude80 1. Vision Statement","text":"<p>HALDI delivers a single, trustworthy hierarchical release view that unifies Epics and Stories per release, makes progress and remaining scope obvious, surfaces open bugs and tasks by priority, and flags delays with indicative timeline impact \u2014 enabling managers to spot risks early, align stakeholders, and publish clear, consistent release updates with near\u2011zero manual effort.</p>"},{"location":"vision/#2-target-users-personas","title":"\ud83d\udc64 2. Target Users / Personas","text":"<ul> <li>Project Managers: Own release tracking, need clear hierarchical visibility and publishable progress.</li> <li>Delivery/Engineering Managers: Ensure sprint-to-release alignment, need signals on delays, bugs, and workload.</li> <li>Product Owners/Product Managers (Secondary): Define release scope and priorities; consume clarity on progress and risks.</li> <li>Leadership Stakeholders (Secondary): Require concise, consistent release updates to make decisions.</li> </ul>"},{"location":"vision/#3-problem-statements","title":"\ud83e\udde9 3. Problem Statements","text":"<ul> <li>Fragmented Visibility: Epics/Stories span multiple releases; no single hierarchical view per release leads to manual, error-prone reporting.</li> <li>Hidden Quality/Workload Signals: Open bugs and tasks linked to Stories aren\u2019t visible in release progress views, obscuring risk and capacity.</li> <li>Delay Blind Spots: Delays tracked informally; timeline shift impacts aren\u2019t surfaced early, causing downstream planning issues.</li> <li>Manual Publishing Overhead: Release updates require ad-hoc consolidation into decks/emails, reducing consistency and speed.</li> </ul> <p>Risks &amp; challenges: - Data reliability: Inconsistent use of fixVersion/labels may affect release membership accuracy. - Adoption: Teams must link Stories to Epics and keep statuses current for meaningful insights. - Technical constraints: Phase 1 avoids complex forecasting; timeline shift remains indicative, not predictive.</p>"},{"location":"vision/#4-core-features-capabilities","title":"\ud83c\udf1f 4. Core Features / Capabilities","text":"<ul> <li>Hierarchical Release View (Primary): Epic \u2192 Story structure targeted to a release, even when items span releases.</li> <li>Progress Signals (Primary): Status and counts at Epic and Story levels; completion vs. remaining scope.</li> <li>Quality &amp; Workload Signals (Primary): Open Bugs by priority and open Tasks per Story with statuses.</li> <li>Delay Highlighting (Primary): Flag delayed Stories and infer indicative timeline shift for remaining work.</li> <li>Report Publishing (Secondary): Generate/export/share a clear release progress report with minimal manual effort.</li> </ul>"},{"location":"vision/#5-business-goals-success-metrics","title":"\ud83c\udfaf 5. Business Goals / Success Metrics","text":"<ul> <li>Release Coverage: \u2265 95% Epics/Stories correctly mapped to selected release.</li> <li>Hierarchical Completeness: \u2265 90% Epics with fully linked Stories visible in release view.</li> <li>Progress Accuracy (Phase 1): \u2265 95% validation via manual PM confirmation.</li> <li>Quality Signal Visibility: 100% visibility of open bugs by priority; flag SLA breach for P1 bugs.</li> <li>Workload Signal Visibility: 100% visibility of open tasks per Story by status.</li> <li>Delay Detection: \u2265 90% of delayed Stories correctly flagged with indicative impact.</li> <li>Report Efficiency: \u2264 5 minutes to generate/share a release report.</li> <li>Manual Reduction: \u2265 80% reduction in manual consolidation vs. baseline.</li> <li>Adoption: \u2265 70% weekly active PM/DM users generating reports within 6 weeks.</li> </ul>"},{"location":"vision/#6-scope-boundaries","title":"\ud83d\udd2d 6. Scope &amp; Boundaries","text":"<p>In Scope (MVP): - Hierarchical release view (Epics \u2192 Stories), progress states, bugs/tasks visibility. - Delay highlighting with indicative timeline shift (simple heuristics; no complex forecasting). - Report publishing/export (PDF/Markdown/Link), minimal configuration.</p> <p>Out of Scope: - Organization-wide productivity benchmarking. - Automated notifications or reminder workflows. - Complex predictive scheduling models beyond indicative shift. - Financial/resource capacity planning.</p> <p>Major goals: - MVP (2-day hackathon): Core flows with manual PM validation for progress accuracy. - Near-term: Stabilize API integrations; refine delay heuristics; improve export formats. - Future: Optional notifications; richer forecasting; capacity overlays.</p>"},{"location":"vision/#7-timeline-milestones","title":"\ud83d\udcc5 7. Timeline / Milestones","text":"<ul> <li>Day 1 \u2014 Data &amp; Hierarchy: Connect to work management APIs (e.g., Jira); fetch Epics, Stories, Bugs, Tasks; implement release membership via fixVersion/labels; render Epic \u2192 Story hierarchy with basic progress.</li> <li>Day 2 \u2014 Signals &amp; Reporting: Add bugs/tasks visibility, delay highlighting with indicative timeline shift; implement report export (Markdown/PDF/Link); finalize manual PM confirmation flow.</li> </ul> <p>Reasoning &amp; constraints: - Tight timeline prioritizes essential visibility and export; advanced forecasting deferred. - Dependencies on data hygiene (consistent labels, issue links) and API limits may impact depth of signals. - Bottlenecks: API rate limits, inconsistent status histories, cross-release linking edge cases.</p>"},{"location":"vision/#8-strategic-differentiators","title":"\ud83d\udccc 8. Strategic Differentiators","text":"<ul> <li>Hierarchy-first: True Epic \u2192 Story hierarchy per release, even for spanning items.</li> <li>Risk signals integrated: Bugs (by priority) and tasks are visible alongside progress.</li> <li>Delay awareness: Indicative timeline shift surfaces downstream impact early without heavy modeling.</li> <li>Near\u2011zero manual publishing: One-click report generation reduces ad-hoc consolidation and increases consistency.</li> </ul>"},{"location":"implementation/","title":"Implementation","text":"<p>This section hosts module-specific specifications and links.</p>"},{"location":"implementation/#modules","title":"Modules","text":"<ul> <li>UI-CODEGEN: See <code>implementation/UI-CODEGEN/phase-1-product-spec.md</code> for Phase 1 PRD.</li> <li>JIRA-CLIENT: See <code>implementation/JIRA-CLIENT/phase-1-product-spec.md</code> for Phase 1 PRD.</li> <li>DATA-LAYER: See <code>implementation/DATA-LAYER/phase-1-product-spec.md</code> for Phase 1 PRD.</li> <li>APP-APIS: See <code>implementation/APP-APIS/phase-1-product-spec.md</code> for Phase 1 PRD.</li> <li>USER-INTERFACE: See <code>implementation/USER-INTERFACE/phase-1-product-spec.md</code> for Phase 1 PRD.</li> </ul>"},{"location":"implementation/frontend-integration-flow/","title":"Frontend Integration Implementation Flow","text":""},{"location":"implementation/frontend-integration-flow/#overview","title":"\ud83c\udfaf Overview","text":"<p>This guide details the step-by-step process for integrating the existing frontend (<code>New Project Setup</code>) with the backend APIs once they're ready.</p> <p>Prerequisites: - Backend APIs deployed and accessible - Frontend project in <code>New Project Setup</code> folder - API endpoints tested with Postman/curl</p>"},{"location":"implementation/frontend-integration-flow/#integration-phases","title":"\ud83d\udccb Integration Phases","text":""},{"location":"implementation/frontend-integration-flow/#phase-1-api-configuration-day-1","title":"Phase 1: API Configuration (Day 1)","text":""},{"location":"implementation/frontend-integration-flow/#step-1-update-api-base-url","title":"Step 1: Update API Base URL","text":"<p>File: <code>New Project Setup/src/services/api.ts</code></p> <pre><code>// BEFORE (Mock mode)\nconst API_BASE_URL = '/api';\nconst MOCK_DELAY = 800;\n\n// AFTER (Production mode)\nconst API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api';\n// Remove MOCK_DELAY - no longer needed\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#step-2-create-environment-configuration","title":"Step 2: Create Environment Configuration","text":"<p>File: <code>New Project Setup/.env.development</code></p> <pre><code>VITE_API_BASE_URL=http://localhost:3000/api\n</code></pre> <p>File: <code>New Project Setup/.env.production</code></p> <pre><code>VITE_API_BASE_URL=https://your-production-domain.com/api\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#step-3-configure-vite-proxy-optional-for-development-cors","title":"Step 3: Configure Vite Proxy (Optional - for development CORS)","text":"<p>File: <code>New Project Setup/vite.config.ts</code></p> <pre><code>import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react-swc';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx', '.json'],\n    alias: {\n      // ... existing aliases ...\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n  // Add proxy configuration for backend API\n  server: {\n    proxy: {\n      '/api': {\n        target: 'http://localhost:3000',\n        changeOrigin: true,\n        secure: false,\n        rewrite: (path) =&gt; path, // Keep /api prefix\n      },\n    },\n  },\n});\n</code></pre> <p>With proxy: - Frontend: <code>http://localhost:5173</code> - API calls: <code>http://localhost:5173/api/*</code> \u2192 proxied to \u2192 <code>http://localhost:3000/api/*</code> - No CORS issues during development</p>"},{"location":"implementation/frontend-integration-flow/#phase-2-replace-mock-functions-day-1-2","title":"Phase 2: Replace Mock Functions (Day 1-2)","text":""},{"location":"implementation/frontend-integration-flow/#task-1-replace-fetchprojects","title":"Task 1: Replace <code>fetchProjects</code>","text":"<p>File: <code>New Project Setup/src/services/api.ts</code></p> <pre><code>// BEFORE (Mock)\nexport const fetchProjects = async (): Promise&lt;Project[]&gt; =&gt; {\n  return mockApiCall([\n    { id: 'proj-1', name: 'Customer Portal Redesign' },\n    // ... mock data\n  ]);\n};\n\n// AFTER (Real API)\nexport const fetchProjects = async (): Promise&lt;Project[]&gt; =&gt; {\n  try {\n    const response = await fetch(`${API_BASE_URL}/projects`);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Failed to fetch projects:', error);\n    throw error;\n  }\n};\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#task-2-replace-fetchreleases","title":"Task 2: Replace <code>fetchReleases</code>","text":"<pre><code>// BEFORE (Mock)\nexport const fetchReleases = async (projectId: string): Promise&lt;Release[]&gt; =&gt; {\n  return mockApiCall([\n    { id: 'rel-1', name: 'Q1 2024 Release', projectId },\n    // ... mock data\n  ]);\n};\n\n// AFTER (Real API)\nexport const fetchReleases = async (projectId: string): Promise&lt;Release[]&gt; =&gt; {\n  try {\n    const response = await fetch(\n      `${API_BASE_URL}/releases?projectId=${encodeURIComponent(projectId)}`\n    );\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.items || []; // Backend returns { version, items, pageInfo }\n  } catch (error) {\n    console.error('Failed to fetch releases:', error);\n    throw error;\n  }\n};\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#task-3-replace-fetchmetrics","title":"Task 3: Replace <code>fetchMetrics</code>","text":"<pre><code>// BEFORE (Mock)\nexport const fetchMetrics = async (releaseId: string): Promise&lt;MetricData[]&gt; =&gt; {\n  return mockApiCall([/* mock metrics */]);\n};\n\n// AFTER (Real API)\nexport const fetchMetrics = async (releaseId: string): Promise&lt;MetricData[]&gt; =&gt; {\n  try {\n    // Use alias endpoint that backend provides\n    const response = await fetch(`${API_BASE_URL}/releases/${releaseId}/metrics`);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Transform backend KPIs to frontend MetricData format\n    return transformKPIsToMetrics(data.kpis);\n  } catch (error) {\n    console.error('Failed to fetch metrics:', error);\n    throw error;\n  }\n};\n\n// Helper function to transform backend KPIs\nfunction transformKPIsToMetrics(kpis: any): MetricData[] {\n  return [\n    {\n      label: 'Overall Completion',\n      value: kpis.overallCompletion || '0%',\n      change: kpis.completionChange || '+0%',\n      trend: kpis.completionTrend || 'neutral',\n      icon: 'Target',\n      color: 'text-[--color-chart-1]',\n      bgColor: 'bg-[--color-chart-1] bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-green-50 to-emerald-50'\n    },\n    {\n      label: 'Epics Completed',\n      value: kpis.epicsCompleted || '0/0',\n      change: kpis.epicsPercentage || '0%',\n      trend: 'neutral',\n      icon: 'Layers',\n      color: 'text-[--color-chart-2]',\n      bgColor: 'bg-[--color-chart-2] bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-orange-50 to-amber-50'\n    },\n    {\n      label: 'Stories On Track',\n      value: kpis.storiesOnTrack || '0/0',\n      change: kpis.storiesPercentage || '0%',\n      trend: 'neutral',\n      icon: 'BookCheck',\n      color: 'text-[--color-chart-1]',\n      bgColor: 'bg-[--color-chart-1] bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-blue-50 to-cyan-50'\n    },\n    {\n      label: 'Delayed Items',\n      value: String(kpis.delayedItems || 0),\n      change: kpis.delayedChange || '+0',\n      trend: (kpis.delayedItems || 0) &gt; 0 ? 'down' : 'up',\n      icon: 'Clock',\n      color: 'text-primary',\n      bgColor: 'bg-primary bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-red-50 to-rose-50'\n    },\n    {\n      label: 'Open Bugs',\n      value: String(kpis.openBugs || 0),\n      change: kpis.bugsChange || '0',\n      trend: (kpis.openBugs || 0) &lt; 10 ? 'up' : 'down',\n      icon: 'ShieldAlert',\n      color: 'text-primary',\n      bgColor: 'bg-primary bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-pink-50 to-fuchsia-50'\n    },\n    {\n      label: 'Open Tasks',\n      value: String(kpis.openTasks || 0),\n      change: kpis.tasksChange || '0',\n      trend: (kpis.openTasks || 0) &lt; 50 ? 'up' : 'down',\n      icon: 'ListTodo',\n      color: 'text-[--color-chart-3]',\n      bgColor: 'bg-[--color-chart-3] bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-purple-50 to-violet-50'\n    }\n  ];\n}\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#task-4-replace-fetchepics","title":"Task 4: Replace <code>fetchEpics</code>","text":"<pre><code>// BEFORE (Mock)\nexport const fetchEpics = async (releaseId: string): Promise&lt;Epic[]&gt; =&gt; {\n  return mockApiCall([/* mock epics */]);\n};\n\n// AFTER (Real API)\nexport const fetchEpics = async (releaseId: string): Promise&lt;Epic[]&gt; =&gt; {\n  try {\n    // Use alias endpoint that backend provides\n    const response = await fetch(`${API_BASE_URL}/releases/${releaseId}/epics`);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Backend returns { version, release, epics, orphanedStories?, notes? }\n    return data.epics || [];\n  } catch (error) {\n    console.error('Failed to fetch epics:', error);\n    throw error;\n  }\n};\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#task-5-replace-fetchchartdata","title":"Task 5: Replace <code>fetchChartData</code>","text":"<pre><code>// BEFORE (Mock)\nexport const fetchChartData = async (releaseId: string): Promise&lt;ChartData&gt; =&gt; {\n  return mockApiCall({/* mock chart data */});\n};\n\n// AFTER (Real API)\nexport const fetchChartData = async (releaseId: string): Promise&lt;ChartData&gt; =&gt; {\n  try {\n    const response = await fetch(`${API_BASE_URL}/releases/${releaseId}/charts`);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Failed to fetch chart data:', error);\n    // Return empty chart data structure on error\n    return {\n      completionTrend: [],\n      statusDistribution: [],\n      velocityData: [],\n      bugTrend: []\n    };\n  }\n};\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#task-6-remove-mock-helper-function","title":"Task 6: Remove Mock Helper Function","text":"<pre><code>// DELETE THIS - no longer needed\nconst mockApiCall = &lt;T,&gt;(data: T, delay = MOCK_DELAY): Promise&lt;T&gt; =&gt; {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; resolve(data), delay);\n  });\n};\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#phase-3-error-handling-loading-states-day-2","title":"Phase 3: Error Handling &amp; Loading States (Day 2)","text":""},{"location":"implementation/frontend-integration-flow/#task-1-add-error-boundary-component","title":"Task 1: Add Error Boundary Component","text":"<p>File: <code>New Project Setup/src/components/ErrorBoundary.tsx</code></p> <pre><code>import React, { Component, ErrorInfo, ReactNode } from 'react';\nimport { Alert, AlertDescription, AlertTitle } from './ui/alert';\nimport { AlertCircle } from 'lucide-react';\n\ninterface Props {\n  children: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ErrorBoundary extends Component&lt;Props, State&gt; {\n  public state: State = {\n    hasError: false\n  };\n\n  public static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Uncaught error:', error, errorInfo);\n  }\n\n  public render() {\n    if (this.state.hasError) {\n      return (\n        &lt;div className=\"flex items-center justify-center min-h-screen p-4\"&gt;\n          &lt;Alert variant=\"destructive\" className=\"max-w-lg\"&gt;\n            &lt;AlertCircle className=\"h-4 w-4\" /&gt;\n            &lt;AlertTitle&gt;Something went wrong&lt;/AlertTitle&gt;\n            &lt;AlertDescription&gt;\n              {this.state.error?.message || 'An unexpected error occurred'}\n            &lt;/AlertDescription&gt;\n          &lt;/Alert&gt;\n        &lt;/div&gt;\n      );\n    }\n\n    return this.props.children;\n  }\n}\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#task-2-update-apptsx-with-better-error-handling","title":"Task 2: Update App.tsx with Better Error Handling","text":"<p>File: <code>New Project Setup/src/App.tsx</code></p> <p>IMPORTANT: Your current <code>App.tsx</code> already has good error handling! Here's what to verify:</p> <pre><code>// EXISTING error handling in App.tsx - VERIFY THIS WORKS:\nif (error) {\n  return (\n    &lt;div className=\"min-h-screen bg-background flex items-center justify-center\"&gt;\n      &lt;div className=\"text-center\"&gt;\n        &lt;p className=\"text-primary mb-4\"&gt;{error}&lt;/p&gt;\n        &lt;button \n          onClick={() =&gt; window.location.reload()} \n          className=\"px-4 py-2 bg-primary text-primary-foreground rounded-[--radius-md]\"\n        &gt;\n          Retry\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\n// EXISTING loading state - VERIFY THIS WORKS:\n{loading &amp;&amp; !metrics.length ? (\n  &lt;div className=\"flex items-center justify-center py-12\"&gt;\n    &lt;div className=\"text-muted-foreground\"&gt;Loading dashboard data...&lt;/div&gt;\n  &lt;/div&gt;\n) : (\n  // ... dashboard content\n)}\n</code></pre> <p>Optional Enhancement: Add ErrorBoundary component only if you want to catch React component errors <pre><code>#### Task 3: Add Loading Skeleton Components\n\n**File:** `New Project Setup/src/components/LoadingSkeleton.tsx`\n\n```typescript\nimport { Skeleton } from './ui/skeleton';\n\nexport function MetricsSkeleton() {\n  return (\n    &lt;div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\"&gt;\n      {[1, 2, 3, 4, 5, 6].map((i) =&gt; (\n        &lt;Skeleton key={i} className=\"h-32 w-full\" /&gt;\n#### Task 3: Enhanced Loading States (Optional)\n\n**Your App.tsx already has basic loading!** Current implementation:\n\n```typescript\n// EXISTING - This already works!\n{loading &amp;&amp; !metrics.length ? (\n  &lt;div className=\"flex items-center justify-center py-12\"&gt;\n    &lt;div className=\"text-muted-foreground\"&gt;Loading dashboard data...&lt;/div&gt;\n  &lt;/div&gt;\n) : (\n  // ... components\n)}\n</code></pre></p> <p>Optional Enhancement: Add skeleton loading with existing <code>Skeleton</code> component:</p> <p>File: <code>New Project Setup/src/components/LoadingSkeleton.tsx</code> (NEW FILE - Optional)</p> <pre><code>import { Skeleton } from './ui/skeleton';\n\nexport function MetricsSkeleton() {\n  return (\n    &lt;div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\"&gt;\n      {[1, 2, 3, 4, 5, 6].map((i) =&gt; (\n        &lt;Skeleton key={i} className=\"h-32 w-full\" /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n\nexport function HierarchySkeleton() {\n  return (\n    &lt;div className=\"space-y-4\"&gt;\n      {[1, 2, 3].map((i) =&gt; (\n        &lt;Skeleton key={i} className=\"h-48 w-full\" /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Then update App.tsx to use skeletons:</p> <pre><code>{loading &amp;&amp; !metrics.length ? (\n  &lt;&gt;\n    &lt;MetricsSkeleton /&gt;\n    &lt;HierarchySkeleton /&gt;\n  &lt;/&gt;\n) : (\n  // ... dashboard content\n)} ] Frontend dev server running on `http://localhost:5173`\n- [ ] No CORS errors in browser console\n- [ ] Network tab shows API calls to correct endpoints\n\n## Data Flow Testing\n\n- [ ] Projects load in dropdown selector\n- [ ] Selecting project loads releases\n- [ ] Selecting release loads dashboard data\n- [ ] Metrics display with correct values\n- [ ] Hierarchy view shows epics and stories\n- [ ] Charts render with real data\n\n## Error Handling Testing\n\n- [ ] Backend offline \u2192 shows error message\n- [ ] Invalid release ID \u2192 shows empty state\n- [ ] Network timeout \u2192 shows error and retry button\n- [ ] Empty data \u2192 shows appropriate empty state message\n\n## Edge Cases Testing\n\n- [ ] Orphaned stories display correctly\n- [ ] Spanning epics show partial indicators\n- [ ] Delayed items highlighted properly\n- [ ] Bug/task counts accurate\n- [ ] Status colors match status categories\n\n## Performance Testing\n\n- [ ] Dashboard loads within 3 seconds\n- [ ] No unnecessary API re-fetches\n- [ ] Loading states show during data fetch\n- [ ] Smooth transitions between selections\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#phase-5-production-readiness-day-3-4","title":"Phase 5: Production Readiness (Day 3-4)","text":""},{"location":"implementation/frontend-integration-flow/#step-1-add-api-error-logging","title":"Step 1: Add API Error Logging","text":"<p>File: <code>New Project Setup/src/services/api.ts</code></p> <pre><code>// Add error logging utility\nfunction logApiError(endpoint: string, error: any) {\n  console.error(`API Error [${endpoint}]:`, {\n    message: error.message,\n    status: error.status,\n    timestamp: new Date().toISOString(),\n  });\n\n  // In production, send to error tracking service\n  if (import.meta.env.PROD) {\n    // Example: Sentry.captureException(error);\n  }\n}\n\n// Use in all fetch functions\nexport const fetchProjects = async (): Promise&lt;Project[]&gt; =&gt; {\n  try {\n    const response = await fetch(`${API_BASE_URL}/projects`);\n    if (!response.ok) throw new Error(`HTTP ${response.status}`);\n    return await response.json();\n  } catch (error) {\n    logApiError('fetchProjects', error);\n    throw error;\n  }\n};\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#step-2-add-request-timeout","title":"Step 2: Add Request Timeout","text":"<pre><code>// Utility function\nasync function fetchWithTimeout(url: string, options: RequestInit = {}, timeout = 10000) {\n  const controller = new AbortController();\n  const id = setTimeout(() =&gt; controller.abort(), timeout);\n\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal\n    });\n    clearTimeout(id);\n    return response;\n  } catch (error) {\n    clearTimeout(id);\n    throw error;\n  }\n}\n\n// Use in API calls\nexport const fetchProjects = async (): Promise&lt;Project[]&gt; =&gt; {\n  try {\n    const response = await fetchWithTimeout(`${API_BASE_URL}/projects`);\n    if (!response.ok) throw new Error(`HTTP ${response.status}`);\n    return await response.json();\n  } catch (error) {\n    logApiError('fetchProjects', error);\n    throw error;\n  }\n};\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#step-3-add-response-caching-optional","title":"Step 3: Add Response Caching (Optional)","text":"<pre><code>// Simple in-memory cache\nconst cache = new Map&lt;string, { data: any; timestamp: number }&gt;();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nfunction getCachedData&lt;T&gt;(key: string): T | null {\n  const cached = cache.get(key);\n  if (!cached) return null;\n\n  const isExpired = Date.now() - cached.timestamp &gt; CACHE_TTL;\n  if (isExpired) {\n    cache.delete(key);\n    return null;\n  }\n\n  return cached.data as T;\n}\n\nfunction setCachedData&lt;T&gt;(key: string, data: T): void {\n  cache.set(key, { data, timestamp: Date.now() });\n}\n\n// Use in API calls\nexport const fetchReleases = async (projectId: string): Promise&lt;Release[]&gt; =&gt; {\n  const cacheKey = `releases_${projectId}`;\n  const cached = getCachedData&lt;Release[]&gt;(cacheKey);\n  if (cached) return cached;\n\n  try {\n    const response = await fetchWithTimeout(\n      `${API_BASE_URL}/releases?projectId=${encodeURIComponent(projectId)}`\n    );\n    if (!response.ok) throw new Error(`HTTP ${response.status}`);\n    const data = await response.json();\n    const releases = data.items || [];\n    setCachedData(cacheKey, releases);\n    return releases;\n  } catch (error) {\n    logApiError('fetchReleases', error);\n    throw error;\n  }\n};\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#quick-start-commands","title":"\ud83d\ude80 Quick Start Commands","text":""},{"location":"implementation/frontend-integration-flow/#start-development-environment","title":"Start Development Environment","text":"<pre><code># Terminal 1: Start Backend\ncd apps/bff-hk-gamar\nnpm run start:dev\n\n# Terminal 2: Start Frontend\ncd \"New Project Setup\"\nnpm install  # if not done already\nnpm run dev\n\n# Open browser\nopen http://localhost:5173\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#verify-integration","title":"Verify Integration","text":"<pre><code># Check backend health\ncurl http://localhost:3000/api/health\n\n# Check projects endpoint\ncurl http://localhost:3000/api/projects\n\n# Check releases endpoint\ncurl \"http://localhost:3000/api/releases?projectId=PROJ-1\"\n\n# Open browser DevTools and check:\n# - Network tab for API calls\n# - Console for errors\n</code></pre>"},{"location":"implementation/frontend-integration-flow/#troubleshooting-guide","title":"\ud83d\udd0d Troubleshooting Guide","text":""},{"location":"implementation/frontend-integration-flow/#issue-cors-errors","title":"Issue: CORS Errors","text":"<p>Symptoms: Browser console shows CORS policy errors</p> <p>Solutions: 1. Ensure backend has CORS enabled in <code>main.ts</code> 2. Use Vite proxy configuration (see Phase 1, Step 3) 3. Check <code>Access-Control-Allow-Origin</code> headers in backend</p>"},{"location":"implementation/frontend-integration-flow/#issue-api-returns-404","title":"Issue: API Returns 404","text":"<p>Symptoms: All API calls fail with 404</p> <p>Solutions: 1. Verify backend is running: <code>curl http://localhost:3000/api/health</code> 2. Check API base URL in frontend <code>.env</code> file 3. Verify endpoint paths match backend routes</p>"},{"location":"implementation/frontend-integration-flow/#issue-empty-data-display","title":"Issue: Empty Data Display","text":"<p>Symptoms: UI loads but shows no data</p> <p>Solutions: 1. Check backend database has data: <code>npx prisma studio</code> 2. Run ingestion pipeline to populate database 3. Check browser DevTools Network tab for API responses 4. Verify DTO transformation functions</p>"},{"location":"implementation/frontend-integration-flow/#issue-slow-loading","title":"Issue: Slow Loading","text":"<p>Symptoms: Dashboard takes &gt;5 seconds to load</p> <p>Solutions: 1. Check backend API response times 2. Optimize database queries (add indexes) 3. Enable response caching 4. Use pagination for large datasets</p>"},{"location":"implementation/frontend-integration-flow/#integration-completion-checklist","title":"\u2705 Integration Completion Checklist","text":""},{"location":"implementation/frontend-integration-flow/#phase-1-configuration","title":"Phase 1: Configuration","text":"<ul> <li> API base URL configured</li> <li> Environment files created</li> <li> Vite proxy configured (if needed)</li> <li> CORS working correctly</li> </ul>"},{"location":"implementation/frontend-integration-flow/#phase-2-api-integration","title":"Phase 2: API Integration","text":"<ul> <li> All mock functions replaced</li> <li> <code>fetchProjects</code> working</li> <li> <code>fetchReleases</code> working</li> <li> <code>fetchMetrics</code> working</li> <li> <code>fetchEpics</code> working</li> <li> <code>fetchChartData</code> working</li> </ul>"},{"location":"implementation/frontend-integration-flow/#phase-3-error-handling","title":"Phase 3: Error Handling","text":"<ul> <li> Error boundary component added</li> <li> Loading skeletons implemented</li> <li> Error messages display correctly</li> <li> Retry mechanism works</li> </ul>"},{"location":"implementation/frontend-integration-flow/#phase-4-testing","title":"Phase 4: Testing","text":"<ul> <li> All API endpoints tested</li> <li> Data displays correctly in UI</li> <li> Error scenarios handled</li> <li> Edge cases validated</li> <li> Performance acceptable (&lt;3s load)</li> </ul>"},{"location":"implementation/frontend-integration-flow/#phase-5-production-ready","title":"Phase 5: Production Ready","text":"<ul> <li> Error logging implemented</li> <li> Request timeouts added</li> <li> Caching implemented (optional)</li> <li> Production environment variables set</li> <li> Final end-to-end testing passed</li> </ul>"},{"location":"implementation/frontend-integration-flow/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<ul> <li>Backend Implementation Flow</li> <li>APP-APIS Development Tasks</li> <li>Technical Specifications</li> </ul>"},{"location":"implementation/frontend-integration-flow/#success-criteria","title":"\ud83c\udf89 Success Criteria","text":"<p>Your frontend integration is complete when:</p> <ol> <li>\u2705 Dashboard loads with real Jira data</li> <li>\u2705 All metrics calculate correctly</li> <li>\u2705 Epic-Story hierarchy displays properly</li> <li>\u2705 Bug and task counts are accurate</li> <li>\u2705 Error states handled gracefully</li> <li>\u2705 Performance meets requirements (&lt;3s load time)</li> <li>\u2705 No console errors or warnings</li> <li>\u2705 Ready for demo to stakeholders</li> </ol> <p>Congratulations! Your MVP is now fully integrated! \ud83d\ude80</p>"},{"location":"implementation/implementation-flow/","title":"Backend Implementation Flow","text":""},{"location":"implementation/implementation-flow/#recommended-implementation-flow","title":"\ud83d\ude80 Recommended Implementation Flow","text":""},{"location":"implementation/implementation-flow/#phase-1-foundation-week-1-2","title":"Phase 1: Foundation (Week 1-2)","text":"<p>Start with parallel setup:</p>"},{"location":"implementation/implementation-flow/#developer-a-jira-client-foundation","title":"Developer A: JIRA-CLIENT Foundation","text":"<ol> <li>TASK-A001: Setup Jira client module structure (2 points, 1 day)</li> <li>TASK-A002: Implement authentication (3 points, 1-2 days)</li> <li>TASK-B001: Fetch releases (3 points, 1 day)</li> <li>Quick validation: Test connection to your actual Jira instance</li> </ol>"},{"location":"implementation/implementation-flow/#developer-b-data-layer-foundation","title":"Developer B: DATA-LAYER Foundation","text":"<ol> <li>TASK-A001: Setup PostgreSQL + Prisma (3 points, 1-2 days)</li> <li>TASK-A002: Design schema and run migrations (5 points, 2-3 days)</li> <li>Verify: Check schema with <code>npx prisma studio</code></li> </ol> <p>Why this order? Both teams can work independently without blocking each other.</p>"},{"location":"implementation/implementation-flow/#phase-2-core-data-pipeline-week-2-3","title":"Phase 2: Core Data Pipeline (Week 2-3)","text":""},{"location":"implementation/implementation-flow/#developer-a-complete-jira-client","title":"Developer A: Complete JIRA-CLIENT","text":"<ol> <li>TASK-B002: Fetch Epics/Stories with JQL (5 points, 2-3 days)</li> <li>TASK-C002: Rate-limit handling (5 points, 2 days) - Do this in parallel with B002</li> <li>TASK-B003: Fetch Bugs/Tasks (3 points, 1 day)</li> <li>TASK-C001: Pagination (3 points, 1 day)</li> <li>TASK-C003: Normalization (3 points, 1 day)</li> </ol>"},{"location":"implementation/implementation-flow/#developer-b-data-layer-ingestion","title":"Developer B: DATA-LAYER Ingestion","text":"<ol> <li>TASK-B001: Release ingestion (3 points, 1 day)</li> <li>TASK-B002: Epic ingestion (3 points, 1 day)</li> <li>TASK-B003: Story ingestion (5 points, 2 days)</li> <li>TASK-B004: Bug/Task ingestion (3 points, 1 day)</li> </ol> <p>Critical checkpoint: Run full ingestion from Jira \u2192 Database and verify data quality.</p>"},{"location":"implementation/implementation-flow/#phase-3-read-services-api-week-3-4","title":"Phase 3: Read Services &amp; API (Week 3-4)","text":""},{"location":"implementation/implementation-flow/#developer-b-data-layer-read-services","title":"Developer B: DATA-LAYER Read Services","text":"<ol> <li>TASK-C001: Release list service (2 points, 1 day)</li> <li>TASK-C002: Hierarchy service (5 points, 2 days)</li> <li>TASK-C003: Signals aggregation (5 points, 2 days)</li> </ol>"},{"location":"implementation/implementation-flow/#developer-a-app-apis-starts-after-jira-client-done","title":"Developer A: APP-APIS (starts after JIRA-CLIENT done)","text":"<ol> <li>TASK-A001: Setup NestJS API module (2 points, 1 day)</li> <li>TASK-A002: Error handling (3 points, 1 day)</li> <li>TASK-B001: Releases endpoint (3 points, 1 day)</li> <li>TASK-B002: Hierarchy endpoint (5 points, 2 days)</li> <li>TASK-B003: Signals endpoint (5 points, 2 days)</li> </ol> <p>Test with Postman/curl: Verify all endpoints return correct data.</p>"},{"location":"implementation/implementation-flow/#phase-4-frontend-integration-week-4-5","title":"Phase 4: Frontend Integration (Week 4-5)","text":""},{"location":"implementation/implementation-flow/#both-developers-together","title":"Both Developers Together","text":"<ol> <li>APP-APIS TASK-C001: Frontend aliases (2 points, 1 day)</li> <li>APP-APIS TASK-C002: Projects endpoint (2 points, 0.5 day)</li> <li>APP-APIS TASK-C003: DTO mapping refinement (3 points, 1 day)</li> <li>Frontend Update: Modify <code>New Project Setup/src/services/api.ts</code>: <pre><code>// Change this:\nconst API_BASE_URL = '/api';\n\n// Add proxy in vite.config.ts or point to:\nconst API_BASE_URL = 'http://localhost:3000/api';\n</code></pre></li> <li>APP-APIS TASK-D002: Frontend integration testing (3 points, 1-2 days)</li> </ol> <p>Demo milestone: Full UI working with real backend data! \ud83c\udf89</p>"},{"location":"implementation/implementation-flow/#phase-5-testing-polish-week-5-6","title":"Phase 5: Testing &amp; Polish (Week 5-6)","text":""},{"location":"implementation/implementation-flow/#parallel-testing","title":"Parallel Testing","text":"<ul> <li> <p>Developer A: </p> <ul> <li>JIRA-CLIENT TASK-D001: Integration tests (5 points)</li> <li>APP-APIS TASK-D001: API integration tests (5 points)</li> </ul> </li> <li> <p>Developer B:</p> <ul> <li>DATA-LAYER TASK-D001: Audit logging (3 points)</li> <li>DATA-LAYER TASK-D002: Integration tests (5 points)</li> </ul> </li> </ul>"},{"location":"implementation/implementation-flow/#documentation-both","title":"Documentation (both)","text":"<ul> <li>JIRA-CLIENT TASK-D002: API docs (2 points)</li> <li>DATA-LAYER TASK-D003: Schema docs (2 points)</li> <li>APP-APIS TASK-D003: OpenAPI spec (2 points)</li> </ul>"},{"location":"implementation/implementation-flow/#quick-start-commands","title":"\ud83c\udfaf Quick Start Commands","text":""},{"location":"implementation/implementation-flow/#day-1-setup","title":"Day 1 Setup","text":"<pre><code># Developer A: JIRA-CLIENT\nnx g @nx/node:library jira-client\ncd libs/jira-client\nnpm install @nestjs/axios axios dotenv\n\n# Developer B: DATA-LAYER\nnx g @nx/node:library data-layer\ncd libs/data-layer\nnpm install prisma @prisma/client\nnpx prisma init\n\n# Setup PostgreSQL\ndocker run --name haldi-postgres -e POSTGRES_PASSWORD=dev123 -p 5432:5432 -d postgres:15\n\n# Create .env file\ncat &gt; .env &lt;&lt; EOF\nDATABASE_URL=\"postgresql://postgres:dev123@localhost:5432/haldi_dev\"\nJIRA_BASE_URL=\"https://your-domain.atlassian.net\"\nJIRA_EMAIL=\"your-email@domain.com\"\nJIRA_API_TOKEN=\"your-api-token-here\"\nEOF\n</code></pre>"},{"location":"implementation/implementation-flow/#week-2-checkpoint","title":"Week 2 Checkpoint","text":"<pre><code># Test JIRA-CLIENT\ncd libs/jira-client\nnpm test\n\n# Test ingestion pipeline\ncd apps/bff-hk-gamar\nnpm run ingest:releases\nnpm run ingest:epics -- --releaseId=&lt;some-id&gt;\n\n# Check database\nnpx prisma studio\n</code></pre>"},{"location":"implementation/implementation-flow/#week-4-integration","title":"Week 4 Integration","text":"<pre><code># Start backend\ncd apps/bff-hk-gamar\nnpm run start:dev\n\n# Start frontend\ncd \"New Project Setup\"\nnpm run dev\n\n# Open http://localhost:5173 and test!\n</code></pre>"},{"location":"implementation/implementation-flow/#critical-success-factors","title":"\u26a0\ufe0f Critical Success Factors","text":"<ol> <li>Start small: Get one release ingested before scaling</li> <li>Test early: Verify Jira connectivity on Day 1</li> <li>Database first: Schema must be solid before ingestion</li> <li>Incremental frontend: Test each endpoint before moving to next</li> <li>Daily demos: Show working features daily to maintain momentum</li> </ol>"},{"location":"implementation/implementation-flow/#iterative-validation-points","title":"\ud83d\udd04 Iterative Validation Points","text":"<ul> <li>\u2705 Day 3: Can authenticate with Jira and fetch one release</li> <li>\u2705 Week 2: One release fully ingested in database</li> <li>\u2705 Week 3: API returns data for one release</li> <li>\u2705 Week 4: Frontend displays real dashboard data</li> <li>\u2705 Week 5: All features working end-to-end</li> <li>\u2705 Week 6: Tests passing, ready for demo</li> </ul>"},{"location":"implementation/implementation-flow/#component-summary","title":"\ud83d\udcca Component Summary","text":"Component Story Points Days Key Tasks JIRA-CLIENT 34 15-19 Auth, Fetch data, Rate-limiting, Normalization DATA-LAYER 44 18-25 Schema, Ingestion, Read services, Aggregation APP-APIS 35 15-20 Endpoints, Error handling, Frontend integration Total 113 48-64 With 2 devs in parallel: 6-8 weeks"},{"location":"implementation/implementation-flow/#task-dependencies-overview","title":"\ud83d\uddfa\ufe0f Task Dependencies Overview","text":"<pre><code>graph TD\n    subgraph \"Week 1-2: Foundation\"\n        JA1[JIRA: Setup + Auth]\n        DA1[DATA: DB + Schema]\n    end\n\n    subgraph \"Week 2-3: Data Pipeline\"\n        JB[JIRA: Fetch All Entities]\n        DB[DATA: Ingestion Pipeline]\n    end\n\n    subgraph \"Week 3-4: APIs\"\n        DC[DATA: Read Services]\n        AB[APP: REST Endpoints]\n    end\n\n    subgraph \"Week 4-5: Integration\"\n        AC[APP: Frontend Layer]\n        FE[Frontend Integration]\n    end\n\n    subgraph \"Week 5-6: Testing\"\n        TEST[All Tests + Docs]\n    end\n\n    JA1 --&gt; JB\n    DA1 --&gt; DB\n    JB --&gt; DB\n    DB --&gt; DC\n    DC --&gt; AB\n    AB --&gt; AC\n    AC --&gt; FE\n    FE --&gt; TEST\n\n    classDef foundation fill:#e1f5fe,stroke:#01579b\n    classDef pipeline fill:#f3e5f5,stroke:#4a148c\n    classDef api fill:#e8f5e8,stroke:#1b5e20\n    classDef integration fill:#fff3e0,stroke:#e65100\n    classDef testing fill:#fce4ec,stroke:#c2185b\n\n    class JA1,DA1 foundation\n    class JB,DB pipeline\n    class DC,AB api\n    class AC,FE integration\n    class TEST testing</code></pre>"},{"location":"implementation/implementation-flow/#start-here","title":"\ud83d\udea6 Start Here","text":"<p>Immediate next steps:</p> <ol> <li> <p>Review the detailed task documents:</p> <ul> <li>JIRA-CLIENT/phase-1-development-tasks.md</li> <li>DATA-LAYER/phase-1-development-tasks.md</li> <li>APP-APIS/phase-1-development-tasks.md</li> </ul> </li> <li> <p>Setup your development environment (Day 1 commands above)</p> </li> <li> <p>Create Jira epics and import tasks</p> </li> <li> <p>Start with JIRA-CLIENT TASK-A001 and DATA-LAYER TASK-A001 in parallel</p> </li> </ol> <p>This flow prioritizes working software over comprehensive documentation and ensures you have a deployable MVP at each milestone. \ud83d\ude80</p>"},{"location":"implementation/mvp-execution-flow/","title":"MVP Execution Flow: Build \u2192 Integrate \u2192 Test \u2192 Proceed","text":""},{"location":"implementation/mvp-execution-flow/#overview","title":"\ud83c\udfaf Overview","text":"<p>This document defines the incremental development flow for building the MVP. Each feature follows the pattern: Backend \u2192 Frontend Integration \u2192 Testing \u2192 Validation before moving to the next feature.</p> <p>Core Principle: Ship working features incrementally, not all at once.</p>"},{"location":"implementation/mvp-execution-flow/#execution-pattern-per-feature","title":"\ud83d\udd04 Execution Pattern (Per Feature)","text":"<pre><code>graph LR\n    A[Build Backend] --&gt; B[Integrate Frontend]\n    B --&gt; C[Test E2E]\n    C --&gt; D{Tests Pass?}\n    D --&gt;|Yes| E[Demo Feature]\n    D --&gt;|No| F[Debug &amp; Fix]\n    F --&gt; C\n    E --&gt; G[Proceed to Next]\n\n    style A fill:#e1f5fe,stroke:#01579b\n    style B fill:#f3e5f5,stroke:#4a148c\n    style C fill:#e8f5e8,stroke:#1b5e20\n    style E fill:#fff3e0,stroke:#e65100</code></pre>"},{"location":"implementation/mvp-execution-flow/#feature-1-project-release-selection","title":"\ud83d\udce6 Feature 1: Project &amp; Release Selection","text":""},{"location":"implementation/mvp-execution-flow/#goal","title":"Goal","text":"<p>User can select a project and see its releases in dropdown selectors.</p>"},{"location":"implementation/mvp-execution-flow/#step-11-backend-projects-list-api","title":"Step 1.1: Backend - Projects List API","text":"<p>Duration: 1-2 days</p> <p>Tasks: - [ ] DATA-LAYER: Add distinct project query in read service - [ ] APP-APIS: Implement <code>GET /api/projects</code> endpoint - [ ] Endpoint returns: <code>[{ id: 'PROJ-1', name: 'Project Name' }]</code></p> <p>Test Backend: <pre><code># Start backend\ncd apps/bff-hk-gamar\nnpm run start:dev\n\n# Test endpoint\ncurl http://localhost:3000/api/projects\n# Expected: [{\"id\":\"PROJ-1\",\"name\":\"Project Name\"}]\n</code></pre></p> <p>Validation: - \u2705 Endpoint returns 200 with array of projects - \u2705 Projects have valid <code>id</code> and <code>name</code> fields - \u2705 Empty array returned if no data (not error)</p>"},{"location":"implementation/mvp-execution-flow/#step-12-backend-releases-list-api","title":"Step 1.2: Backend - Releases List API","text":"<p>Duration: 1-2 days</p> <p>Tasks: - [ ] DATA-LAYER: Implement <code>listReleases(filters, pagination)</code> service - [ ] APP-APIS: Implement <code>GET /api/releases?projectId=XXX</code> endpoint - [ ] Handle pagination: <code>{ version, items: [...], pageInfo: {...} }</code></p> <p>Test Backend: <pre><code># Test endpoint\ncurl \"http://localhost:3000/api/releases?projectId=PROJ-1\"\n# Expected: {\"version\":\"v1\",\"items\":[...],\"pageInfo\":{...}}\n</code></pre></p> <p>Validation: - \u2705 Endpoint returns releases for valid project - \u2705 Empty items array for project with no releases - \u2705 Pagination metadata included - \u2705 400 error for missing projectId</p>"},{"location":"implementation/mvp-execution-flow/#step-13-frontend-integration","title":"Step 1.3: Frontend Integration","text":"<p>Duration: 0.5-1 day</p> <p>Tasks: - [ ] Update <code>src/services/api.ts</code>:</p> <pre><code>// Replace fetchProjects mock\nexport const fetchProjects = async (): Promise&lt;Project[]&gt; =&gt; {\n  const response = await fetch(`${API_BASE_URL}/projects`);\n  if (!response.ok) throw new Error(`HTTP ${response.status}`);\n  return await response.json();\n};\n\n// Replace fetchReleases mock\nexport const fetchReleases = async (projectId: string): Promise&lt;Release[]&gt; =&gt; {\n  const response = await fetch(\n    `${API_BASE_URL}/releases?projectId=${encodeURIComponent(projectId)}`\n  );\n  if (!response.ok) throw new Error(`HTTP ${response.status}`);\n  const data = await response.json();\n  return data.items || [];\n};\n</code></pre> <ul> <li> <p> Add <code>.env.development</code>: <pre><code>VITE_API_BASE_URL=http://localhost:3000/api\n</code></pre></p> </li> <li> <p> Update <code>api.ts</code>: <pre><code>const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '/api';\n</code></pre></p> </li> </ul> <p>Test Frontend: <pre><code># Start frontend\ncd \"New Project Setup\"\nnpm run dev\n\n# Open browser: http://localhost:5173\n# Check: Project dropdown should load real projects\n# Check: Selecting project loads real releases\n</code></pre></p> <p>Validation: - \u2705 Project dropdown populates from backend - \u2705 Release dropdown loads when project selected - \u2705 No CORS errors in console - \u2705 Network tab shows successful API calls</p>"},{"location":"implementation/mvp-execution-flow/#step-14-end-to-end-testing","title":"Step 1.4: End-to-End Testing","text":"<p>Duration: 0.5 day</p> <p>Test Scenarios:</p> <ol> <li> <p>Happy Path:</p> <ul> <li> Open dashboard \u2192 projects load</li> <li> Select project \u2192 releases load</li> <li> Switch project \u2192 releases update</li> </ul> </li> <li> <p>Error Scenarios:</p> <ul> <li> Backend offline \u2192 error message displays</li> <li> Invalid project ID \u2192 empty releases</li> <li> Network timeout \u2192 retry button works</li> </ul> </li> <li> <p>Edge Cases:</p> <ul> <li> Project with no releases \u2192 empty state</li> <li> Very long project names \u2192 UI doesn't break</li> <li> Rapid project switching \u2192 no race conditions</li> </ul> </li> </ol> <p>Validation Checklist: - \u2705 All scenarios pass - \u2705 No console errors - \u2705 Loading states work correctly - \u2705 Error handling is user-friendly</p>"},{"location":"implementation/mvp-execution-flow/#step-15-demo-proceed","title":"Step 1.5: Demo &amp; Proceed","text":"<p>Demo Checkpoint: - Show working project/release selection to team - Get feedback on UX - Document any issues found</p> <p>If tests pass: \u2705 Proceed to Feature 2</p>"},{"location":"implementation/mvp-execution-flow/#feature-2-dashboard-metrics-kpis","title":"\ud83d\udce6 Feature 2: Dashboard Metrics (KPIs)","text":""},{"location":"implementation/mvp-execution-flow/#goal_1","title":"Goal","text":"<p>Display 6 KPI metrics cards on dashboard for selected release.</p>"},{"location":"implementation/mvp-execution-flow/#step-21-backend-data-layer-signals-service","title":"Step 2.1: Backend - Data Layer Signals Service","text":"<p>Duration: 2-3 days</p> <p>Tasks: - [ ] DATA-LAYER TASK-C003: Implement <code>getReleaseSignals(releaseId)</code> service - [ ] Calculate KPIs:     - Overall completion %     - Epics completed (count)     - Stories on track (count)     - Delayed items (count)     - Open bugs (count)     - Open tasks (count) - [ ] Group bugs by priority - [ ] Group tasks by status</p> <p>Test Backend: <pre><code># Test signals endpoint\ncurl http://localhost:3000/api/release/rel-1/signals\n# Expected: {\"version\":\"v1\",\"kpis\":{...},\"bugs\":{...},\"tasks\":{...}}\n</code></pre></p> <p>Validation: - \u2705 All KPI calculations correct - \u2705 Bug grouping by priority works - \u2705 Task grouping by status works - \u2705 404 for invalid release ID</p>"},{"location":"implementation/mvp-execution-flow/#step-22-backend-signals-api-endpoint","title":"Step 2.2: Backend - Signals API Endpoint","text":"<p>Duration: 1-2 days</p> <p>Tasks: - [ ] APP-APIS TASK-B003: Implement <code>GET /api/release/:id/signals</code> endpoint - [ ] APP-APIS TASK-C001: Add alias <code>GET /api/releases/:id/metrics</code> - [ ] Map DATA-LAYER response to frontend format</p> <p>Test Backend: <pre><code># Test both endpoints\ncurl http://localhost:3000/api/release/rel-1/signals\ncurl http://localhost:3000/api/releases/rel-1/metrics\n# Both should return KPIs in frontend-compatible format\n</code></pre></p> <p>Validation: - \u2705 Signals endpoint returns KPIs - \u2705 Alias endpoint works identically - \u2705 Response format matches frontend <code>MetricData[]</code> interface - \u2705 Calculations match database state</p>"},{"location":"implementation/mvp-execution-flow/#step-23-frontend-integration","title":"Step 2.3: Frontend Integration","text":"<p>Duration: 0.5-1 day</p> <p>Tasks: - [ ] Update <code>src/services/api.ts</code>:</p> <pre><code>// Replace fetchMetrics mock\nexport const fetchMetrics = async (releaseId: string): Promise&lt;MetricData[]&gt; =&gt; {\n  const response = await fetch(\n    `${API_BASE_URL}/releases/${releaseId}/metrics`\n  );\n  if (!response.ok) throw new Error(`HTTP ${response.status}`);\n  const data = await response.json();\n\n  // Transform backend KPIs to frontend MetricData format\n  return [\n    {\n      label: 'Overall Completion',\n      value: data.kpis.overallCompletion || '0%',\n      change: data.kpis.completionChange || '+0%',\n      trend: data.kpis.overallCompletion &gt; '50%' ? 'up' : 'neutral',\n      icon: 'Target',\n      color: 'text-[--color-chart-1]',\n      bgColor: 'bg-[--color-chart-1] bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-green-50 to-emerald-50'\n    },\n    {\n      label: 'Epics Completed',\n      value: data.kpis.epicsCompleted || '0/0',\n      change: data.kpis.epicsPercentage || '0%',\n      trend: 'neutral',\n      icon: 'Layers',\n      color: 'text-[--color-chart-2]',\n      bgColor: 'bg-[--color-chart-2] bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-orange-50 to-amber-50'\n    },\n    {\n      label: 'Stories On Track',\n      value: data.kpis.storiesOnTrack || '0/0',\n      change: data.kpis.storiesPercentage || '0%',\n      trend: 'neutral',\n      icon: 'BookCheck',\n      color: 'text-[--color-chart-1]',\n      bgColor: 'bg-[--color-chart-1] bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-blue-50 to-cyan-50'\n    },\n    {\n      label: 'Delayed Items',\n      value: String(data.kpis.delayedItems || 0),\n      change: data.kpis.delayedChange || '+0',\n      trend: data.kpis.delayedItems &gt; 0 ? 'down' : 'up',\n      icon: 'Clock',\n      color: 'text-primary',\n      bgColor: 'bg-primary bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-red-50 to-rose-50'\n    },\n    {\n      label: 'Open Bugs',\n      value: String(data.kpis.openBugs || 0),\n      change: data.kpis.bugsChange || '0',\n      trend: data.kpis.openBugs &lt; 10 ? 'up' : 'down',\n      icon: 'ShieldAlert',\n      color: 'text-primary',\n      bgColor: 'bg-primary bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-pink-50 to-fuchsia-50'\n    },\n    {\n      label: 'Open Tasks',\n      value: String(data.kpis.openTasks || 0),\n      change: data.kpis.tasksChange || '0',\n      trend: data.kpis.openTasks &lt; 50 ? 'up' : 'down',\n      icon: 'ListTodo',\n      color: 'text-[--color-chart-3]',\n      bgColor: 'bg-[--color-chart-3] bg-opacity-10',\n      cardBg: 'bg-gradient-to-br from-purple-50 to-violet-50'\n    }\n  ];\n};\n</code></pre> <p>Test Frontend: <pre><code># Verify metrics display\n# 1. Select release\n# 2. Check 6 metric cards render\n# 3. Verify values match backend data\n</code></pre></p> <p>Validation: - \u2705 Metrics cards display with real data - \u2705 Values update when release changes - \u2705 Trend indicators (up/down/neutral) correct - \u2705 No layout issues with varying value lengths</p>"},{"location":"implementation/mvp-execution-flow/#step-24-end-to-end-testing","title":"Step 2.4: End-to-End Testing","text":"<p>Test Scenarios:</p> <ol> <li> <p>Data Accuracy:</p> <ul> <li> Completion % matches database calculations</li> <li> Bug/task counts accurate</li> <li> Delayed items count correct</li> </ul> </li> <li> <p>Dynamic Updates:</p> <ul> <li> Switching releases updates metrics</li> <li> Loading state shows during fetch</li> <li> Error state for invalid release</li> </ul> </li> <li> <p>Visual Validation:</p> <ul> <li> All 6 cards display correctly</li> <li> Icons render properly</li> <li> Color coding appropriate for values</li> </ul> </li> </ol> <p>Validation: - \u2705 All calculations verified against database - \u2705 UI updates smoothly - \u2705 No data inconsistencies</p>"},{"location":"implementation/mvp-execution-flow/#step-25-demo-proceed","title":"Step 2.5: Demo &amp; Proceed","text":"<p>Demo Checkpoint: - Show working metrics dashboard - Validate calculations with actual Jira data - Get stakeholder feedback</p> <p>If tests pass: \u2705 Proceed to Feature 3</p>"},{"location":"implementation/mvp-execution-flow/#feature-3-epic-story-hierarchy-view","title":"\ud83d\udce6 Feature 3: Epic-Story Hierarchy View","text":""},{"location":"implementation/mvp-execution-flow/#goal_2","title":"Goal","text":"<p>Display nested Epic \u2192 Stories hierarchy with status indicators.</p>"},{"location":"implementation/mvp-execution-flow/#step-31-backend-hierarchy-service","title":"Step 3.1: Backend - Hierarchy Service","text":"<p>Duration: 2-3 days</p> <p>Tasks: - [ ] DATA-LAYER TASK-C002: Implement <code>getReleaseHierarchy(releaseId)</code> service - [ ] Fetch Epics with nested Stories (single query, no N+1) - [ ] Include edge-case flags: <code>partial</code>, <code>multiLinked</code>, <code>unlinked</code> - [ ] Calculate epic progress from story completion - [ ] Handle orphaned stories</p> <p>Test Backend: <pre><code>curl http://localhost:3000/api/release/rel-1/hierarchy\n# Expected: {\"version\":\"v1\",\"release\":{...},\"epics\":[...],\"orphanedStories\":[...]}\n</code></pre></p> <p>Validation: - \u2705 Epics include nested stories - \u2705 Epic progress calculated correctly - \u2705 Orphaned stories in separate array - \u2705 Edge-case flags set appropriately - \u2705 Query optimized (no N+1 problem)</p>"},{"location":"implementation/mvp-execution-flow/#step-32-backend-hierarchy-api-endpoint","title":"Step 3.2: Backend - Hierarchy API Endpoint","text":"<p>Duration: 1-2 days</p> <p>Tasks: - [ ] APP-APIS TASK-B002: Implement <code>GET /api/release/:id/hierarchy</code> endpoint - [ ] APP-APIS TASK-C001: Add alias <code>GET /api/releases/:id/epics</code> - [ ] Map status categories to frontend enum: <code>completed</code>, <code>inProgress</code>, <code>delayed</code>, <code>notStarted</code> - [ ] Calculate story delay status</p> <p>Test Backend: <pre><code>curl http://localhost:3000/api/releases/rel-1/epics\n# Verify status mapping and progress calculations\n</code></pre></p> <p>Validation: - \u2705 Status mapped correctly - \u2705 Delayed stories flagged (delayDays &gt; 0) - \u2705 Bug/task counts included per story - \u2705 Both endpoints work identically</p>"},{"location":"implementation/mvp-execution-flow/#step-33-frontend-integration","title":"Step 3.3: Frontend Integration","text":"<p>Duration: 0.5-1 day</p> <p>Tasks: - [ ] Update <code>src/services/api.ts</code>:</p> <pre><code>// Replace fetchEpics mock\nexport const fetchEpics = async (releaseId: string): Promise&lt;Epic[]&gt; =&gt; {\n  const response = await fetch(\n    `${API_BASE_URL}/releases/${releaseId}/epics`\n  );\n  if (!response.ok) throw new Error(`HTTP ${response.status}`);\n  const data = await response.json();\n  return data.epics || [];\n};\n</code></pre> <p>Test Frontend: <pre><code># Verify hierarchy view\n# 1. Select release\n# 2. Check HierarchyView component displays epics\n# 3. Verify nested stories show under each epic\n# 4. Check delayed items highlighted\n</code></pre></p> <p>Validation: - \u2705 Hierarchy renders with real data - \u2705 Epic progress bars accurate - \u2705 Story status colors correct - \u2705 Delayed items highlighted - \u2705 Bug/task counts display</p>"},{"location":"implementation/mvp-execution-flow/#step-34-end-to-end-testing","title":"Step 3.4: End-to-End Testing","text":"<p>Test Scenarios:</p> <ol> <li> <p>Hierarchy Structure:</p> <ul> <li> Epics display in correct order</li> <li> Stories nested under correct epic</li> <li> Orphaned stories shown separately</li> </ul> </li> <li> <p>Status Indicators:</p> <ul> <li> Completed items green</li> <li> In-progress items blue</li> <li> Delayed items red/orange</li> <li> Not started items gray</li> </ul> </li> <li> <p>Edge Cases:</p> <ul> <li> Epic with no stories displays correctly</li> <li> Story with 0 bugs/tasks shows properly</li> <li> Very long epic/story names don't break layout</li> </ul> </li> </ol> <p>Validation: - \u2705 Hierarchy matches database structure - \u2705 All status indicators accurate - \u2705 Layout handles edge cases</p>"},{"location":"implementation/mvp-execution-flow/#step-35-demo-proceed","title":"Step 3.5: Demo &amp; Proceed","text":"<p>Demo Checkpoint: - Show working hierarchy visualization - Demonstrate drill-down from epic to stories - Validate delayed item detection</p> <p>If tests pass: \u2705 Proceed to Feature 4</p>"},{"location":"implementation/mvp-execution-flow/#feature-4-charts-visualizations","title":"\ud83d\udce6 Feature 4: Charts &amp; Visualizations","text":""},{"location":"implementation/mvp-execution-flow/#goal_3","title":"Goal","text":"<p>Display completion trends, status distribution, and bug/task charts.</p>"},{"location":"implementation/mvp-execution-flow/#step-41-backend-chart-data-derivation","title":"Step 4.1: Backend - Chart Data Derivation","text":"<p>Duration: 1-2 days</p> <p>Tasks: - [ ] APP-APIS: Implement <code>GET /api/releases/:id/charts</code> endpoint - [ ] Derive chart data from existing signals and hierarchy - [ ] Or implement stub with basic time-series data</p> <p>Note: For MVP, charts can be simplified or stubbed initially.</p> <p>Test Backend: <pre><code>curl http://localhost:3000/api/releases/rel-1/charts\n</code></pre></p>"},{"location":"implementation/mvp-execution-flow/#step-42-frontend-integration","title":"Step 4.2: Frontend Integration","text":"<p>Duration: 0.5-1 day</p> <p>Tasks: - [ ] Replace <code>fetchChartData</code> mock in <code>api.ts</code> - [ ] Verify chart components render with real data</p>"},{"location":"implementation/mvp-execution-flow/#step-43-testing-demo","title":"Step 4.3: Testing &amp; Demo","text":"<p>Validation: - \u2705 Charts display data accurately - \u2705 Visual representations clear - \u2705 Responsive on different screen sizes</p> <p>If tests pass: \u2705 MVP Feature Complete!</p>"},{"location":"implementation/mvp-execution-flow/#complete-mvp-integration-checklist","title":"\ud83c\udfaf Complete MVP Integration Checklist","text":""},{"location":"implementation/mvp-execution-flow/#backend-completion","title":"Backend Completion","text":"<ul> <li> All JIRA-CLIENT tasks completed</li> <li> All DATA-LAYER tasks completed</li> <li> All APP-APIS tasks completed</li> <li> Database populated with ingestion pipeline</li> <li> All endpoints tested with Postman/curl</li> </ul>"},{"location":"implementation/mvp-execution-flow/#frontend-integration","title":"Frontend Integration","text":"<ul> <li> All 5 API functions replaced (no mocks remaining)</li> <li> <code>.env</code> files configured</li> <li> CORS working (no errors)</li> <li> Loading states functional</li> <li> Error handling working</li> </ul>"},{"location":"implementation/mvp-execution-flow/#end-to-end-testing","title":"End-to-End Testing","text":"<ul> <li> Project/release selection works</li> <li> Metrics display accurately</li> <li> Hierarchy shows correct structure</li> <li> Charts render properly</li> <li> All edge cases handled</li> <li> Performance acceptable (&lt;3s load)</li> </ul>"},{"location":"implementation/mvp-execution-flow/#production-readiness","title":"Production Readiness","text":"<ul> <li> Error logging implemented</li> <li> Request timeouts added</li> <li> Environment variables documented</li> <li> Deployment guide created</li> <li> User documentation written</li> </ul>"},{"location":"implementation/mvp-execution-flow/#progress-tracking","title":"\ud83d\udcca Progress Tracking","text":"<p>Use this table to track completion:</p> Feature Backend Frontend Testing Demo Status 1. Project/Release Selection \u2b1c \u2b1c \u2b1c \u2b1c Not Started 2. Dashboard Metrics \u2b1c \u2b1c \u2b1c \u2b1c Not Started 3. Hierarchy View \u2b1c \u2b1c \u2b1c \u2b1c Not Started 4. Charts/Visualizations \u2b1c \u2b1c \u2b1c \u2b1c Not Started <p>Legend: \u2b1c Not Started | \ud83d\udfe1 In Progress | \u2705 Complete</p>"},{"location":"implementation/mvp-execution-flow/#quick-start-begin-feature-1","title":"\ud83d\ude80 Quick Start: Begin Feature 1","text":"<pre><code># Terminal 1: Backend Development\ncd apps/bff-hk-gamar\nnpm run start:dev\n\n# Terminal 2: Frontend Development  \ncd \"New Project Setup\"\nnpm run dev\n\n# Terminal 3: Testing/Verification\n# Run curl commands and test in browser\n</code></pre> <p>Start with Feature 1, Step 1.1 and follow the flow sequentially. Each feature builds on the previous, ensuring stable incremental progress toward your MVP! \ud83c\udf89</p>"},{"location":"implementation/mvp-execution-flow/#tips-for-success","title":"\ud83d\udca1 Tips for Success","text":"<ol> <li>Don't skip testing steps - catch issues early</li> <li>Demo after each feature - get feedback immediately</li> <li>Document issues as you go - don't forget edge cases</li> <li>Keep backend and frontend in sync - coordinate API contracts</li> <li>Commit working code frequently - maintain stable checkpoints</li> </ol> <p>This incremental approach ensures you always have a working, demo-able product at each stage! \ud83d\ude80</p>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/","title":"Tasks - Phase 1","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#1-task-overview","title":"1. Task Overview","text":"<ul> <li>Component: APP-APIS</li> <li>Phase: 1</li> <li>Technical Spec: phase-1-technical-spec.md</li> <li>Total Estimated Effort: 24 story points</li> <li>Implementation Order: 4 task groups in sequence</li> <li>Phase 1 Scope: REST API endpoints for releases list, hierarchy view, and signals/KPIs with frontend-compatible response contracts, error handling, pagination, and integration with existing frontend</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#2-task-categories","title":"2. Task Categories","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#category-a-foundation-setup","title":"Category A: Foundation &amp; Setup","text":"<p>API infrastructure and routing setup</p>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#category-b-core-endpoints","title":"Category B: Core Endpoints","text":"<p>Primary API endpoints implementation</p>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#category-c-frontend-integration","title":"Category C: Frontend Integration","text":"<p>Frontend compatibility layer and response mapping</p>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#category-d-testing-documentation","title":"Category D: Testing &amp; Documentation","text":"<p>API testing and integration documentation</p>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#3-detailed-task-breakdown","title":"3. Detailed Task Breakdown","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#foundation-setup","title":"\ud83d\udccb Foundation &amp; Setup","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-a001-setup-nestjs-api-module-and-routing-structure","title":"TASK-A001: Setup NestJS API module and routing structure","text":"<ul> <li>Summary: APP-APIS - Setup API Module &amp; Controllers</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 2</li> <li>Priority: High</li> <li>Labels: setup, api, infrastructure, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Setup NestJS module structure in existing <code>apps/bff-hk-gamar</code> with API controllers, routing, and basic middleware configuration.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Create API module in <code>apps/bff-hk-gamar/src/api</code></li> <li>Setup controllers: <code>ReleasesController</code></li> <li>Configure global API prefix: <code>/api</code></li> <li>Enable CORS for frontend development</li> <li>Add request logging middleware</li> <li>Setup validation pipe for DTOs</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>API module registered in <code>AppModule</code></li> <li>Controllers respond to routes: <code>/api/releases</code>, <code>/api/release/:id/*</code></li> <li>CORS enabled for <code>http://localhost:*</code> origins</li> <li>Request logging shows method, path, status, duration</li> <li>Validation pipe automatically validates request DTOs</li> <li>Health check endpoint works: <code>GET /api/health</code></li> </ul> </li> <li> <p>Dependencies: None</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>api</code> module in bff-hk-gamar</li> <li>Generate controllers: <code>nx g @nx/nest:controller releases</code></li> <li>Configure global prefix in <code>main.ts</code></li> <li>Enable CORS middleware</li> <li>Add request logging interceptor</li> <li>Create health check endpoint</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-a002-implement-error-handling-and-response-standardization","title":"TASK-A002: Implement error handling and response standardization","text":"<ul> <li>Summary: APP-APIS - Error Handling &amp; Standard Response Format</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: error-handling, middleware, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Create standardized error handling with exception filters, response wrappers, and correlation ID tracking for debugging.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement global exception filter</li> <li>Standardize error response: <code>{ code, message, details?, correlationId? }</code></li> <li>Map exceptions to HTTP status codes</li> <li>Add correlation ID interceptor for request tracking</li> <li>Create custom exception classes: <code>NotFoundException</code>, <code>ValidationException</code>, <code>InternalException</code></li> <li>Log errors with correlation IDs</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>All exceptions return standardized error format</li> <li>Correlation ID generated for each request</li> <li>Error codes mapped correctly: NOT_FOUND (404), INVALID_ARGUMENT (400), INTERNAL (500)</li> <li>Exception details excluded in production</li> <li>Errors logged with correlation ID for debugging</li> <li>Unit tests verify exception filter behavior</li> </ul> </li> <li> <p>Dependencies: TASK-A001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create global exception filter</li> <li>Implement correlation ID interceptor</li> <li>Create custom exception classes</li> <li>Add error response standardization</li> <li>Configure logging with correlation IDs</li> <li>Write unit tests for error handling</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#core-endpoints","title":"\ud83d\udd27 Core Endpoints","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-b001-implement-releases-list-endpoint","title":"TASK-B001: Implement releases list endpoint","text":"<ul> <li>Summary: APP-APIS - GET /api/releases Endpoint</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: api, endpoint, releases, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Build releases list endpoint with filtering, pagination, and integration with DATA-LAYER read service.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>GET /api/releases</code> route</li> <li>Query params: <code>query</code>, <code>status</code>, <code>page</code>, <code>pageSize</code>, <code>projectId</code></li> <li>Call DATA-LAYER <code>listReleases()</code> service</li> <li>Return paginated response: <code>{ version: \"v1\", items: Release[], pageInfo: {} }</code></li> <li>Pagination defaults: <code>page=1</code>, <code>pageSize=50</code>, max=200</li> <li>Support filtering by name search and status</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Endpoint returns paginated list of releases</li> <li>Query parameter filters releases by name (case-insensitive)</li> <li>Status filter works correctly</li> <li><code>pageInfo</code> includes: <code>page</code>, <code>pageSize</code>, <code>total</code>, <code>nextPageToken?</code></li> <li>Empty array returned when no releases match filters</li> <li>Response includes <code>version: \"v1\"</code> field</li> <li>Integration tests verify filtering and pagination</li> </ul> </li> <li> <p>Dependencies: TASK-A002, DATA-LAYER TASK-C001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>ReleasesController.getReleases()</code> method</li> <li>Add query DTO with validation</li> <li>Integrate DATA-LAYER read service</li> <li>Build response DTO mapper</li> <li>Implement pagination logic</li> <li>Write integration tests</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-b002-implement-hierarchy-endpoint","title":"TASK-B002: Implement hierarchy endpoint","text":"<ul> <li>Summary: APP-APIS - GET /api/release/:id/hierarchy Endpoint</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: api, endpoint, hierarchy, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Build hierarchy endpoint returning Epic-Story nested structure with edge-case indicators for visualization.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>GET /api/release/:id/hierarchy</code> route</li> <li>Path param: <code>id</code> (Release ID)</li> <li>Call DATA-LAYER <code>getReleaseHierarchy()</code> service</li> <li>Return nested structure: <code>{ version: \"v1\", release: {}, epics: [ { id, name, status, stories: [] } ], orphanedStories?: [], notes?: [] }</code></li> <li>Include edge-case flags: <code>partial</code>, <code>multiLinked</code>, <code>unlinked</code></li> <li>Map status categories to frontend format: <code>completed</code>, <code>inProgress</code>, <code>delayed</code>, <code>notStarted</code></li> <li>Calculate epic progress percentage from story completion</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Endpoint returns release with nested epics and stories</li> <li>Epics include nested stories array</li> <li>Orphaned stories returned in separate array</li> <li>Edge-case notes included when applicable</li> <li>Status mapped to frontend enum: <code>completed</code>, <code>inProgress</code>, <code>delayed</code>, <code>notStarted</code></li> <li>Epic progress calculated correctly (% of completed stories)</li> <li>Story <code>delayDays</code> included for delayed items</li> <li>404 error returned for invalid release ID</li> </ul> </li> <li> <p>Dependencies: TASK-A002, DATA-LAYER TASK-C002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>ReleasesController.getHierarchy()</code> method</li> <li>Add path param validation</li> <li>Integrate DATA-LAYER hierarchy service</li> <li>Build response DTO with nested structure</li> <li>Implement status mapping logic</li> <li>Calculate epic progress percentages</li> <li>Handle 404 for missing releases</li> <li>Write integration tests</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-b003-implement-signals-and-kpis-endpoint","title":"TASK-B003: Implement signals and KPIs endpoint","text":"<ul> <li>Summary: APP-APIS - GET /api/release/:id/signals Endpoint</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: api, endpoint, kpi, signals, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Build signals endpoint returning KPI metrics and grouped bugs/tasks for dashboard metrics display.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>GET /api/release/:id/signals</code> route</li> <li>Call DATA-LAYER <code>getReleaseSignals()</code> service</li> <li>Return KPIs: completion %, epics completed, stories on track, delayed items, open bugs, open tasks</li> <li>Return grouped bugs by priority: <code>{ P0, P1, P2, P3, P4, Unclassified }</code></li> <li>Return grouped tasks by status: <code>{ Open, InProgress, Closed }</code></li> <li>Format KPIs for frontend consumption with labels and values</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Endpoint returns comprehensive KPIs object</li> <li>KPIs include: <code>overallCompletion</code>, <code>epicsCompleted</code>, <code>storiesOnTrack</code>, <code>delayedItems</code>, <code>openBugs</code>, <code>openTasks</code></li> <li>Bug counts grouped by priority correctly</li> <li>Task counts grouped by status correctly</li> <li>Percentages formatted as strings (e.g., \"68%\")</li> <li>Counts formatted as strings (e.g., \"12/18\")</li> <li>404 error returned for invalid release ID</li> </ul> </li> <li> <p>Dependencies: TASK-A002, DATA-LAYER TASK-C003</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>ReleasesController.getSignals()</code> method</li> <li>Integrate DATA-LAYER signals service</li> <li>Build KPI response DTO</li> <li>Format percentages and counts</li> <li>Build bug/task grouping response</li> <li>Handle 404 for missing releases</li> <li>Write integration tests</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#frontend-integration","title":"\ud83d\udd17 Frontend Integration","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-c001-create-frontend-compatible-endpoint-aliases","title":"TASK-C001: Create frontend-compatible endpoint aliases","text":"<ul> <li>Summary: APP-APIS - Frontend Compatibility Layer</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 2</li> <li>Priority: High</li> <li>Labels: frontend, integration, compatibility, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Add endpoint aliases to match existing frontend expectations from <code>New Project Setup/src/services/api.ts</code> without requiring frontend refactoring.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Create route aliases:<ul> <li><code>/api/releases/:id/metrics</code> \u2192 maps to signals endpoint (KPIs)</li> <li><code>/api/releases/:id/epics</code> \u2192 maps to hierarchy endpoint</li> <li><code>/api/releases/:id/charts</code> \u2192 stub or derive from signals/hierarchy</li> </ul> </li> <li>Maintain consistent response format across aliases</li> <li>Add deprecation warnings in headers for alias routes</li> <li>Document migration path for frontend</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>/api/releases/:id/metrics</code> returns KPIs (same as signals)</li> <li><code>/api/releases/:id/epics</code> returns hierarchy (same as hierarchy)</li> <li><code>/api/releases/:id/charts</code> returns stub or basic chart data</li> <li>Response formats match frontend expectations</li> <li>Deprecation header added: <code>X-Deprecated: Use /api/release/:id/signals instead</code></li> <li>Frontend can fetch data without modifications</li> </ul> </li> <li> <p>Dependencies: TASK-B002, TASK-B003</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create alias routes in controller</li> <li>Map alias endpoints to primary endpoints</li> <li>Add deprecation warning headers</li> <li>Implement stub for charts endpoint</li> <li>Test frontend integration</li> <li>Document migration path</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-c002-implement-projects-list-endpoint-for-frontend-selector","title":"TASK-C002: Implement projects list endpoint for frontend selector","text":"<ul> <li>Summary: APP-APIS - GET /api/projects Endpoint</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 2</li> <li>Priority: Medium</li> <li>Labels: api, endpoint, projects, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Build projects list endpoint to populate project selector in frontend dashboard header.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>GET /api/projects</code> route</li> <li>Query database for distinct <code>projectId</code> values from releases</li> <li>Return array: <code>[ { id, name } ]</code></li> <li>Name can be derived from project key initially (e.g., \"PROJ-123\" \u2192 \"PROJ-123\")</li> <li>Support future enhancement: fetch project names from Jira or config</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Endpoint returns array of projects</li> <li>Each project has <code>id</code> and <code>name</code> fields</li> <li>Distinct projects extracted from releases table</li> <li>Empty array returned when no releases exist</li> <li>Response format matches frontend interface</li> </ul> </li> <li> <p>Dependencies: TASK-B001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>ProjectsController.getProjects()</code> method</li> <li>Query distinct project IDs from releases</li> <li>Build response DTO</li> <li>Write integration tests</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-c003-map-frontend-data-structures-to-api-responses","title":"TASK-C003: Map frontend data structures to API responses","text":"<ul> <li>Summary: APP-APIS - Response DTO Mapping for Frontend Types</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: frontend, dto, mapping, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Create comprehensive DTO mapping layer to transform database entities into frontend-compatible response formats matching TypeScript interfaces in <code>api.ts</code>.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Map database status to frontend enum: <code>completed</code>, <code>inProgress</code>, <code>delayed</code>, <code>notStarted</code></li> <li>Status mapping logic:<ul> <li><code>Done</code> \u2192 <code>completed</code></li> <li><code>In Progress</code> \u2192 <code>inProgress</code></li> <li>Overdue (delayDays &gt; 0) \u2192 <code>delayed</code></li> <li><code>To Do</code> \u2192 <code>notStarted</code></li> </ul> </li> <li>Calculate progress percentages for epics</li> <li>Format bug/task counts: <code>openBugs</code>, <code>openTasks</code> per story</li> <li>Ensure response shapes match frontend TypeScript interfaces exactly</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>All API responses match frontend TypeScript interfaces</li> <li>Status enum mapping consistent across all endpoints</li> <li>Epic progress calculated from story completion</li> <li>Story includes: <code>openBugs</code>, <code>openTasks</code>, <code>delayDays?</code></li> <li>Unit tests verify DTO mapping correctness</li> <li>No type errors when integrating with frontend</li> </ul> </li> <li> <p>Dependencies: TASK-B002, TASK-B003</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create DTO mapper utility functions</li> <li>Implement status enum mapping</li> <li>Calculate epic progress percentages</li> <li>Add bug/task counts to story responses</li> <li>Write unit tests for all mappers</li> <li>Validate against frontend TypeScript types</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#testing-documentation","title":"\u2728 Testing &amp; Documentation","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-d001-integration-testing-with-data-layer","title":"TASK-D001: Integration testing with DATA-LAYER","text":"<ul> <li>Summary: APP-APIS - Integration Tests with DATA-LAYER</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: testing, integration, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Create comprehensive integration test suite covering all API endpoints with real database connections and DATA-LAYER services.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Setup test database with sample data</li> <li>Test all endpoints: releases, hierarchy, signals, projects</li> <li>Verify response contracts and status codes</li> <li>Test error cases: 404, 400, 500</li> <li>Test pagination and filtering</li> <li>Test edge cases: orphaned stories, spanning epics</li> <li>Measure response times (should be &lt; 3s)</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Integration tests cover all API endpoints</li> <li>Tests use real test database with seeded data</li> <li>Response formats validated against DTOs</li> <li>Error scenarios tested: invalid IDs, missing data</li> <li>Pagination and filtering verified</li> <li>Edge cases validated in responses</li> <li>Performance benchmarks met (p95 &lt; 3s)</li> </ul> </li> <li> <p>Dependencies: TASK-C003</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Setup test database with seed data</li> <li>Write integration tests for releases endpoint</li> <li>Write integration tests for hierarchy endpoint</li> <li>Write integration tests for signals endpoint</li> <li>Test error handling scenarios</li> <li>Test pagination and filtering</li> <li>Add performance benchmarks</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-d002-frontend-integration-testing","title":"TASK-D002: Frontend integration testing","text":"<ul> <li>Summary: APP-APIS - Frontend Integration Verification</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: testing, frontend, integration, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Verify end-to-end integration between backend APIs and existing frontend in <code>New Project Setup</code> folder.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Update frontend <code>api.ts</code> to point to backend endpoints</li> <li>Replace mock API calls with real fetch calls</li> <li>Test all frontend components with real data</li> <li>Verify dashboard renders correctly with backend data</li> <li>Test error handling in UI (empty states, errors)</li> <li>Validate data flow: project selector \u2192 release selector \u2192 dashboard</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Frontend successfully fetches data from backend APIs</li> <li>All dashboard components render with real data</li> <li>Project and release selectors work correctly</li> <li>Metrics, hierarchy, and charts display accurate data</li> <li>Error states handled gracefully in UI</li> <li>No CORS errors or connection issues</li> </ul> </li> <li> <p>Dependencies: TASK-C001, TASK-D001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Update frontend API base URL</li> <li>Replace mock functions with real fetch calls</li> <li>Test project/release selection flow</li> <li>Verify metrics display</li> <li>Test hierarchy view rendering</li> <li>Test error handling in UI</li> <li>Fix any integration issues</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-d003-api-documentation-and-openapi-spec","title":"TASK-D003: API documentation and OpenAPI spec","text":"<ul> <li>Summary: APP-APIS - API Documentation &amp; OpenAPI Specification</li> <li>Issue Type: Story</li> <li>Epic Link: APP-APIS Epic</li> <li>Story Points: 2</li> <li>Priority: Low</li> <li>Labels: documentation, openapi, app-apis</li> <li> <p>Components: APP-APIS</p> </li> <li> <p>Description:</p> <p>Generate comprehensive API documentation with OpenAPI/Swagger specification and interactive API explorer.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Install <code>@nestjs/swagger</code> package</li> <li>Add Swagger decorators to all endpoints</li> <li>Document request/response DTOs</li> <li>Document query parameters and path params</li> <li>Add example responses</li> <li>Enable Swagger UI at <code>/api/docs</code></li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Swagger UI accessible at <code>/api/docs</code></li> <li>All endpoints documented with descriptions</li> <li>Request/response schemas defined</li> <li>Query params and path params documented</li> <li>Example responses provided</li> <li>API can be tested via Swagger UI</li> </ul> </li> <li> <p>Dependencies: TASK-D001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Install Swagger dependencies</li> <li>Add Swagger decorators to controllers</li> <li>Document DTOs with ApiProperty decorators</li> <li>Add example responses</li> <li>Configure Swagger UI</li> <li>Write API usage guide</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#4-task-dependencies-sequencing","title":"4. Task Dependencies &amp; Sequencing","text":"<pre><code>graph TD\n    A001[A001: Setup API Module] --&gt; A002[A002: Error Handling]\n    A002 --&gt; B001[B001: Releases Endpoint]\n    A002 --&gt; B002[B002: Hierarchy Endpoint]\n    A002 --&gt; B003[B003: Signals Endpoint]\n    B002 --&gt; C001[C001: Frontend Aliases]\n    B003 --&gt; C001\n    B001 --&gt; C002[C002: Projects Endpoint]\n    B002 --&gt; C003[C003: DTO Mapping]\n    B003 --&gt; C003\n    C003 --&gt; D001[D001: Integration Tests]\n    C001 --&gt; D002[D002: Frontend Integration]\n    D001 --&gt; D002\n    D001 --&gt; D003[D003: API Documentation]\n\n    classDef foundation fill:#e1f5fe,stroke:#01579b\n    classDef core fill:#f3e5f5,stroke:#4a148c\n    classDef integration fill:#e8f5e8,stroke:#1b5e20\n    classDef polish fill:#fff3e0,stroke:#e65100\n\n    class A001,A002 foundation\n    class B001,B002,B003 core\n    class C001,C002,C003 integration\n    class D001,D002,D003 polish</code></pre>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#5-parallel-development-opportunities","title":"5. Parallel Development Opportunities","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#what-can-be-built-simultaneously","title":"What Can Be Built Simultaneously:","text":"<ul> <li>After A002: B001, B002, and B003 can start in parallel (different endpoints)</li> <li>After B002 and B003: C001 and C003 can start in parallel</li> <li>After D001: D002 and D003 can start in parallel</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#critical-path","title":"Critical Path:","text":"<p>A001 \u2192 A002 \u2192 B002 \u2192 C003 \u2192 D001 \u2192 D002</p>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#6-risk-mitigation-tasks","title":"6. Risk Mitigation Tasks","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#technical-risks","title":"Technical Risks:","text":"<ul> <li>Risk API-R1 (Frontend Breaking Changes): Mitigated in TASK-C001 with endpoint aliases</li> <li>Risk API-R2 (Performance): Basic pagination in TASK-B001; optimize in DATA-LAYER</li> <li>Risk API-R3 (Contract Drift): Version field and DTO mapping in TASK-C003</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#7-definition-of-done","title":"7. Definition of Done","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#task-completion-criteria","title":"Task Completion Criteria:","text":"<ul> <li>\u2705 All acceptance criteria met</li> <li>\u2705 Unit tests written and passing (&gt;80% coverage)</li> <li>\u2705 Code review completed</li> <li>\u2705 Integration tests passing</li> <li>\u2705 API documentation updated</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#component-completion-criteria","title":"Component Completion Criteria:","text":"<ul> <li>\u2705 All tasks completed per definition of done</li> <li>\u2705 Technical specification requirements met</li> <li>\u2705 Integration with frontend verified and working</li> <li>\u2705 Performance targets met (p95 &lt; 3s)</li> <li>\u2705 Ready for MVP deployment</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#8-estimation-summary","title":"8. Estimation Summary","text":"Category Task Count Total Effort Duration (days) Foundation &amp; Setup 2 5 points 2-3 days Core Endpoints 3 13 points 6-7 days Frontend Integration 3 7 points 3-4 days Testing &amp; Documentation 3 10 points 4-6 days TOTAL 11 35 points 15-20 days"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#9-traceability-matrix","title":"9. Traceability Matrix","text":"Task ID Technical Spec Section Functional Requirements Business Value A001 Section 5.1 Setup/Infrastructure API foundation A002 Section 3.3 FR-APP-APIS-004 Error handling B001 Section 3.1 FR-APP-APIS-001 Release listing B002 Section 3.1 FR-APP-APIS-002 Hierarchy visualization B003 Section 3.1 FR-APP-APIS-003 KPI metrics C001 Section 3.1 Frontend Compatibility Seamless integration C002 Section 3.1 UI Project Selector User experience C003 Section 3.2 Response Contracts Type safety D001 Section 10.2 Testing Strategy Quality assurance D002 Section 6.1 Frontend Integration MVP completion D003 Section 11.1 Documentation Developer experience"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#10-implementation-notes","title":"10. Implementation Notes","text":""},{"location":"implementation/APP-APIS/phase-1-development-tasks/#development-best-practices","title":"Development Best Practices:","text":"<ul> <li>Use NestJS decorators for clean controller code</li> <li>Implement DTOs with class-validator for automatic validation</li> <li>Use dependency injection for DATA-LAYER services</li> <li>Keep controllers thin - delegate logic to services</li> <li>Use interceptors for cross-cutting concerns</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#quality-gates","title":"Quality Gates:","text":"<ul> <li>Unit test coverage minimum 80%</li> <li>Integration tests pass with real database</li> <li>Frontend integration verified with no errors</li> <li>API response times &lt; 3s for p95</li> <li>OpenAPI spec generated and accurate</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#communication-plan","title":"Communication Plan:","text":"<ul> <li>Daily standup updates on endpoint progress</li> <li>Demo working endpoints after each core task</li> <li>Frontend integration session with UI developer after TASK-C001</li> <li>Document any API contract changes immediately</li> <li>Share OpenAPI spec with team after TASK-D003</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-development-tasks/#frontend-integration-notes","title":"Frontend Integration Notes:","text":"<ul> <li>Backend runs on: <code>http://localhost:3000</code> (default NestJS port)</li> <li>Frontend proxy configuration may be needed in <code>vite.config.ts</code></li> <li>Update API_BASE_URL in <code>api.ts</code> to <code>/api</code> (proxy) or <code>http://localhost:3000/api</code></li> <li>Test CORS configuration during development</li> <li>Use browser dev tools to verify API responses match frontend expectations</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/","title":"PRD - Phase 1","text":""},{"location":"implementation/APP-APIS/phase-1-product-spec/#1-module-overview","title":"1. Module Overview","text":"<ul> <li>Purpose: Expose backend APIs that serve release lists, hierarchical Epic \u2192 Story views, and signals (KPIs, bugs, tasks) from persisted data.</li> <li>Business Value: Enables the UI to render real data reliably, unlocking user-facing value for tracking and reporting.</li> <li>User Value: PM/DMs can select releases and see hierarchy and signals backed by fresh data.</li> <li>Module Type: Core</li> <li>Phase 1 Scope: Read-only endpoints: <code>/releases</code>, <code>/release/:id/hierarchy</code>, <code>/release/:id/signals</code>; pagination; standardized errors; basic performance targets; auth deferred.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#2-scope-boundaries","title":"2. Scope &amp; Boundaries","text":"<ul> <li>In Scope:<ul> <li>REST endpoints that read from DATA-LAYER entities.</li> <li>Consistent response contracts: shapes for Release, Epic, Story, Bug, Task, KPIs.</li> <li>Pagination, filtering, and sorting where applicable.</li> <li>Standard error format with codes and messages.</li> <li>Basic caching headers (optional) and performance baselines.</li> </ul> </li> <li>Out of Scope:<ul> <li>Write endpoints or admin operations.</li> <li>Authentication/authorization (deferred to later phase).</li> <li>Report generation.</li> </ul> </li> <li>Dependencies:<ul> <li>DATA-LAYER populated with normalized entities.</li> </ul> </li> <li>Dependents:<ul> <li>USER-INTERFACE consumes these endpoints to render views.</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#3-user-personas-contexts","title":"3. User Personas &amp; Contexts","text":"<ul> <li>Persona: Backend/Frontend Engineers; PM/DM via UI.</li> <li>Goals: Serve stable, performant data to UI with clear contracts.</li> <li>Context: MVP; prioritize correctness, clarity, and speed.</li> <li>Pain Points: Inconsistent contracts, slow responses, ambiguous errors.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#4-user-stories","title":"4. User Stories","text":"<ul> <li>US-APP-APIS-001: As a frontend engineer, I want <code>/releases</code> so that users can select a release.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given data exists, when calling <code>/releases</code>, then I get a paginated list with <code>id</code>, <code>name</code>, <code>status</code>, and counts.</li> <li>Given no data, when calling, then I receive an empty list with guidance metadata.</li> </ul> </li> <li>US-APP-APIS-002: As a frontend engineer, I want <code>/release/:id/hierarchy</code> so that the UI can render Epic \u2192 Story structure.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given a valid release ID, when calling, then I receive Epics with nested Stories, edge-case flags (partial/multi-linked/unlinked).</li> <li>Given invalid ID, when calling, then I receive a <code>404</code> error with a clear message.</li> </ul> </li> <li>US-APP-APIS-003: As a frontend engineer, I want <code>/release/:id/signals</code> so that the UI can render KPIs, bugs, and tasks.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given a valid release ID, when calling, then I receive KPIs (completion, epics completed, stories on track, open bugs/tasks, delayed items) and lists grouped by priority/status.</li> <li>Given missing data, when calling, then fields are present with zero/empty values and <code>needsReview</code> flags where appropriate.</li> </ul> </li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#5-functional-requirements","title":"5. Functional Requirements","text":"<ul> <li>FR-APP-APIS-001: Provide <code>/releases</code> with pagination and optional filters (name contains, status).</li> <li>Related Project FR: FR-016, FR-017.</li> <li>Module Context: UI Release Selector.</li> <li>FR-APP-APIS-002: Provide <code>/release/:id/hierarchy</code> delivering Epics and nested Stories with edge-case indicators.</li> <li>Related Project FR: FR-003, FR-004, FR-005.</li> <li>Module Context: Hierarchical view.</li> <li>FR-APP-APIS-003: Provide <code>/release/:id/signals</code> returning KPIs plus Bugs/Tasks grouped by priority/status.</li> <li>Related Project FR: FR-008, FR-009, FR-016, FR-017.</li> <li>Module Context: Signals and summary tiles.</li> <li>FR-APP-APIS-004: Standardize error responses with <code>code</code>, <code>message</code>, and <code>details</code> fields.</li> <li>Related Project FR: FR-015.</li> <li>Module Context: Developer clarity and UI handling.</li> <li>FR-APP-APIS-005: Performance targets: endpoints respond \u2264 3 seconds for typical releases.</li> <li>Related Project FR: Non-functional performance.</li> <li>Module Context: Usability.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#6-business-rules-logic","title":"6. Business Rules &amp; Logic","text":"<ul> <li>BR-APP-APIS-001: Return consistent shapes even when datasets are empty (no surprises).</li> <li>Example: KPIs present with zero values; lists empty arrays; flags available.</li> <li>Edge Cases: Provide <code>needsReview</code> markers for unknown statuses.</li> <li>BR-APP-APIS-002: Pagination defaults and limits prevent overload.</li> <li>Example: Default <code>pageSize</code> = 50; max = 200.</li> <li>Edge Cases: Return <code>nextPageToken</code> when applicable.</li> <li>BR-APP-APIS-003: Edge-case indicators must be surfaced explicitly on hierarchy items.</li> <li>Example: <code>partial</code>, <code>multiLinked</code>, <code>unlinked</code> boolean fields.</li> <li>Edge Cases: Include <code>notes</code> for tooltip content.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#7-user-interface-requirements","title":"7. User Interface Requirements","text":"<ul> <li>None (server-side). Contracts documented for frontend usage.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#8-data-requirements","title":"8. Data Requirements","text":"<ul> <li>Input Data: Persisted entities from DATA-LAYER.</li> <li>Output Data: JSON responses for releases, hierarchy, signals.</li> <li>Stored Data: None (read-only).</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#9-integration-specifications","title":"9. Integration Specifications","text":"<ul> <li>APIs/Interfaces:</li> <li><code>GET /releases?query=&amp;status=&amp;page=&amp;pageSize=</code></li> <li><code>GET /release/:id/hierarchy</code></li> <li><code>GET /release/:id/signals</code></li> <li>Events: None.</li> <li>Data Flow: DB \u2192 API \u2192 UI.</li> <li>Error Handling: Errors standardized; include correlation ID in headers.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#10-performance-quality-requirements","title":"10. Performance &amp; Quality Requirements","text":"<ul> <li>Performance: \u2264 3s typical response; progressive loading for large hierarchies optional.</li> <li>Reliability: Consistent contracts; handle missing data gracefully.</li> <li>Security: Auth deferred; ensure no sensitive data leaks.</li> <li>Usability: Clear field names and types; documented enums for status/priority.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#11-success-metrics","title":"11. Success Metrics","text":"<ul> <li>Business Metrics: UI binds successfully with minimal changes; report generation unblocked.</li> <li>User Metrics: UI loads data within performance targets for typical releases.</li> <li>Technical Metrics: Error rate \u2264 1%; latency p95 \u2264 3s for typical payloads.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#12-edge-cases-error-scenarios","title":"12. Edge Cases &amp; Error Scenarios","text":"<ul> <li>Error Case 1: Release ID not found.</li> <li>User Experience: UI shows not-found state.</li> <li>System Behavior: Return 404 with details.</li> <li>Edge Case 1: Large dataset causing slow hierarchy responses.</li> <li>Business Logic: Offer pagination or progressive loading.</li> <li>User Impact: UI loads sections incrementally.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Enhancement 1: Add auth and role-based access.</li> <li>Enhancement 2: Streaming/progressive endpoints for very large hierarchies.</li> <li>Enhancement 3: Versioned API and OpenAPI spec publication.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#14-acceptance-criteria-summary","title":"14. Acceptance Criteria Summary","text":"<ul> <li> <code>/releases</code> returns paginated lists with filters.</li> <li> <code>/release/:id/hierarchy</code> returns structured Epics/Stories with indicators.</li> <li> <code>/release/:id/signals</code> returns KPIs and grouped Bugs/Tasks.</li> <li> Standardized error format implemented across endpoints.</li> <li> Performance target p95 \u2264 3s for typical releases.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-product-spec/#15-open-questions","title":"15. Open Questions","text":"<ul> <li>Question 1: Which filters/sorts are essential for <code>/releases</code> in Phase 1?</li> <li>Question 2: Should signals include delay heuristic details or just computed KPIs in Phase 1?</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/","title":"TRD - Phase 1","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#1-component-overview","title":"1. Component Overview","text":"<ul> <li>Purpose: Provide read-only backend endpoints for releases, hierarchical Epic \u2192 Story views, and signals required by the MVP UI.</li> <li>Scope: Implement minimal routing and fixed JSON contracts for three endpoints; include pagination and standardized error responses; defer caching and authentication.</li> <li>Phase 1 Scope:</li> <li><code>GET /api/releases</code></li> <li><code>GET /api/release/:id/hierarchy</code></li> <li><code>GET /api/release/:id/signals</code></li> <li>Pagination defaults; standardized error envelope; contract stability</li> <li>Dependencies: DATA-LAYER (persisted entities from Jira), JIRA-CLIENT (for ingestion jobs feeding DATA-LAYER)</li> <li>Dependents: USER-INTERFACE (UI consumes these endpoints), REPORTING (later)</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#2-functional-requirements","title":"2. Functional Requirements","text":"<ul> <li>FR-APP-APIS-001: <code>/releases</code> returns paginated releases with <code>id</code>, <code>name</code>, <code>status</code>, counts</li> <li>FR-APP-APIS-002: <code>/release/:id/hierarchy</code> returns Epics with nested Stories and edge-case flags</li> <li>FR-APP-APIS-003: <code>/release/:id/signals</code> returns KPIs plus grouped Bugs/Tasks</li> <li>FR-APP-APIS-004: Standard error response with <code>code</code>, <code>message</code>, <code>details</code></li> <li>FR-APP-APIS-005: Pagination defaults: <code>pageSize</code>=50, <code>max</code>=200</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#3-component-interface","title":"3. Component Interface","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#31-public-api","title":"3.1 Public API","text":"<ul> <li><code>GET /api/releases?query=&amp;status=&amp;page=&amp;pageSize=</code></li> <li><code>GET /api/release/:id/hierarchy</code></li> <li><code>GET /api/release/:id/signals</code></li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#endpoint-mapping-frontend-compatibility","title":"Endpoint Mapping (Frontend Compatibility)","text":"<ul> <li>UI mock expectations (from <code>New Project Setup/src/services/api.ts</code>) and server routes:</li> <li><code>/api/releases/:id/metrics</code> \u2192 maps to <code>/api/release/:id/signals</code> (return KPIs under <code>kpis</code>)</li> <li><code>/api/releases/:id/epics</code> \u2192 maps to <code>/api/release/:id/hierarchy</code> (return <code>epics</code> array)</li> <li><code>/api/releases/:id/charts</code> \u2192 optional; derive from signals/hierarchy or stub for Phase 1</li> <li>Provide aliases for above paths to minimize frontend refactors.</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#32-inputoutput-contracts","title":"3.2 Input/Output Contracts","text":"<ul> <li>Inputs:</li> <li>Query params: <code>query</code>, <code>status</code>, <code>page</code>, <code>pageSize</code></li> <li>Path param: <code>id</code> (Release ID)</li> <li>Outputs:</li> <li><code>/releases</code>: <code>{ version: \"v1\", items: Release[], pageInfo: { page, pageSize, total, nextPageToken? } }</code></li> <li><code>/release/:id/hierarchy</code>: <code>{ version: \"v1\", release: ReleaseSummary, epics: EpicWithStories[], notes?: string[] }</code></li> <li><code>/release/:id/signals</code>: <code>{ version: \"v1\", kpis: KPIs, bugs: BugsByPriority, tasks: TasksByStatus }</code></li> <li>Data Formats: JSON; types documented in UI stubs and PRD</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#33-error-handling","title":"3.3 Error Handling","text":"<ul> <li>Error Types: <code>NOT_FOUND</code>, <code>INVALID_ARGUMENT</code>, <code>INTERNAL</code>, <code>DEPENDENCY_UNAVAILABLE</code></li> <li>Error Responses: <code>{ code: string, message: string, details?: any }</code> with HTTP status codes; include <code>X-Correlation-Id</code> header</li> <li>Recovery Strategies: Return empty datasets with guidance where appropriate; log correlation ID</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#4-data-model","title":"4. Data Model","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#41-data-storage","title":"4.1 Data Storage","text":"<ul> <li>Storage Type: Application reads from DATA-LAYER (DB) entities populated via ingestion</li> <li>Data Schema: Entities: Release, Epic, Story, Bug, Task (normalized)</li> </ul> <pre><code>-- Illustrative schema (Phase 1 reference)\nCREATE TABLE releases (\n  id UUID PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  status VARCHAR(50) NOT NULL,\n  project_id UUID NOT NULL\n);\n\nCREATE TABLE epics (\n  id UUID PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  status VARCHAR(50) NOT NULL,\n  release_id UUID REFERENCES releases(id)\n);\n\nCREATE TABLE stories (\n  id UUID PRIMARY KEY,\n  epic_id UUID REFERENCES epics(id),\n  name VARCHAR(255) NOT NULL,\n  status VARCHAR(50) NOT NULL,\n  assignee VARCHAR(255),\n  due_date DATE,\n  delay_days INTEGER\n);\n\nCREATE TABLE bugs (\n  id UUID PRIMARY KEY,\n  story_id UUID REFERENCES stories(id),\n  priority VARCHAR(10) NOT NULL,\n  status VARCHAR(50) NOT NULL\n);\n\nCREATE TABLE tasks (\n  id UUID PRIMARY KEY,\n  story_id UUID REFERENCES stories(id),\n  status VARCHAR(50) NOT NULL\n);\n</code></pre>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#42-data-flow","title":"4.2 Data Flow","text":"<pre><code>flowchart TD\n    A[Jira Client] --&gt; B[Ingestion Jobs]\n    B --&gt; C[DATA-LAYER DB]\n    C --&gt; D[APP-APIS]\n    D --&gt; E[USER-INTERFACE]</code></pre>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#43-data-validation","title":"4.3 Data Validation","text":"<ul> <li>Input Validation: Validate <code>pageSize</code> bounds; ensure <code>id</code> format; sanitize <code>query</code></li> <li>Business Rules: Return consistent shapes; include edge-case flags</li> <li>Data Integrity: Read-only; rely on DATA-LAYER normalization</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#5-technology-stack","title":"5. Technology Stack","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#51-core-technologies","title":"5.1 Core Technologies","text":"<ul> <li>Programming Language: TypeScript</li> <li>Framework: NestJS (current backend <code>apps/bff-hk-gamar</code>)</li> <li>Database: As provided by DATA-LAYER (TBD exact tech)</li> <li>Additional Libraries: NestJS common/core; optional class-validator for params</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#52-technology-rationale","title":"5.2 Technology Rationale","text":"<ul> <li>Why These Choices: Aligns with existing NestJS app; fast to implement read APIs</li> <li>Alternatives Considered: Express/Fastify bare; higher effort for contracts/logging</li> <li>Trade-offs: Deferring auth/caching reduces complexity but leaves NFRs for later</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#6-integration-design","title":"6. Integration Design","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#61-dependency-integration","title":"6.1 Dependency Integration","text":"<ul> <li>DATA-LAYER: Service adapters read normalized entities; pagination and filters applied server-side</li> <li>Communication Method: Direct DB/service calls within app context</li> <li>Data Exchange: JSON responses, stable shapes</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#62-service-integration","title":"6.2 Service Integration","text":"<ul> <li>External APIs: None directly (Phase 1 read-only)</li> <li>Authentication: Deferred; internal only for MVP</li> <li>Rate Limiting: Not required in Phase 1</li> <li>Fallback Strategies: Empty datasets and guidance flags</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#71-performance-requirements","title":"7.1 Performance Requirements","text":"<ul> <li>Response Time: p95 \u2264 3s for typical releases (\u2264 50 epics)</li> <li>Throughput: Typical MVP loads; no specific RPS targets</li> <li>Scalability: Basic pagination only</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#72-performance-strategies","title":"7.2 Performance Strategies","text":"<ul> <li>Caching: Deferred</li> <li>Database Optimization: Basic indexes on foreign keys and status fields; avoid N+1 via joins and selective projections</li> <li>Resource Management: Avoid N+1 via simple joins/aggregations</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#8-security-design","title":"8. Security Design","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#81-security-requirements","title":"8.1 Security Requirements","text":"<ul> <li>Authentication: Deferred</li> <li>Authorization: Deferred</li> <li>Data Protection: No sensitive fields returned</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#82-security-implementation","title":"8.2 Security Implementation","text":"<ul> <li>Encryption: TLS via platform</li> <li>Input Sanitization: Validate/sanitize query params</li> <li>Audit Logging: Basic request logs; correlation ID optional</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#9-monitoring-observability","title":"9. Monitoring &amp; Observability","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#91-logging","title":"9.1 Logging","text":"<ul> <li>Log Levels: Info, Error for API calls</li> <li>Log Format: Include path, status, timing</li> <li>Sensitive Data: Do not log tokens or PII</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#92-metrics","title":"9.2 Metrics","text":"<ul> <li>Performance Metrics: Request latency (optional)</li> <li>Business Metrics: Endpoint hit counts (optional)</li> <li>Alerting: None in Phase 1</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#10-testing-strategy","title":"10. Testing Strategy","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#101-unit-testing","title":"10.1 Unit Testing","text":"<ul> <li>Test Coverage: Handlers/services for each endpoint</li> <li>Key Test Cases: Empty datasets, NOT_FOUND, pagination bounds</li> <li>Mock Dependencies: Mock DATA-LAYER adapters</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#102-integration-testing","title":"10.2 Integration Testing","text":"<ul> <li>Integration Points: DB read paths; response contract validation</li> <li>Test Data: Seed minimal Release/Epic/Story/Bug/Task datasets</li> <li>Environment Requirements: Local NestJS app with test DB</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#11-deployment-considerations","title":"11. Deployment Considerations","text":""},{"location":"implementation/APP-APIS/phase-1-technical-spec/#111-environment-requirements","title":"11.1 Environment Requirements","text":"<ul> <li>Infrastructure: Node/NestJS runtime; DB connectivity</li> <li>Configuration: <code>PORT</code>, DB connection settings</li> <li>Secrets Management: None for Phase 1 read-only</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#112-deployment-strategy","title":"11.2 Deployment Strategy","text":"<ul> <li>Build Process: Nx/Nest build, container optional</li> <li>Deployment Steps: Configure env, start server</li> <li>Rollback Plan: Redeploy previous build</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#12-risk-mitigation","title":"12. Risk Mitigation","text":"<ul> <li>Risk R1 (API Rate/Data Hygiene): Mitigated by relying on ingest-normalized DATA-LAYER</li> <li>Risk R2 (Large Payloads): Pagination limits and simple filters</li> <li>Risk R3 (Contract Drift): Documented stable shapes; version fields reserved</li> </ul>"},{"location":"implementation/APP-APIS/phase-1-technical-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Extensibility: Add auth, caching, correlation IDs, OpenAPI spec</li> <li>Migration Path: Introduce v1 versioning and progressive hierarchy streaming</li> <li>Deprecation Strategy: Versioned endpoints, migration guides</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/","title":"Tasks - Phase 1","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#1-task-overview","title":"1. Task Overview","text":"<ul> <li>Component: DATA-LAYER</li> <li>Phase: 1</li> <li>Technical Spec: phase-1-technical-spec.md</li> <li>Total Estimated Effort: 28 story points</li> <li>Implementation Order: 4 task groups in sequence</li> <li>Phase 1 Scope: Database schema setup, ingestion pipeline for Jira entities, normalization and validation, read services for APP-APIS, and basic audit logging</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#2-task-categories","title":"2. Task Categories","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#category-a-foundation-setup","title":"Category A: Foundation &amp; Setup","text":"<p>Database configuration and schema design</p>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#category-b-core-implementation","title":"Category B: Core Implementation","text":"<p>Ingestion pipeline and entity mappers</p>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#category-c-read-services-aggregation","title":"Category C: Read Services &amp; Aggregation","text":"<p>Query services for APP-APIS</p>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#category-d-testing-observability","title":"Category D: Testing &amp; Observability","text":"<p>Testing suite and monitoring</p>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#3-detailed-task-breakdown","title":"3. Detailed Task Breakdown","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#foundation-setup","title":"\ud83d\udccb Foundation &amp; Setup","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-a001-setup-database-infrastructure-and-orm-configuration","title":"TASK-A001: Setup database infrastructure and ORM configuration","text":"<ul> <li>Summary: DATA-LAYER - Database Setup &amp; ORM Configuration</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: setup, database, infrastructure, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Setup PostgreSQL database connection, configure Prisma ORM, and establish database migration infrastructure.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Install PostgreSQL database (local/Docker for dev)</li> <li>Setup Prisma ORM with TypeScript</li> <li>Configure database connection via environment variables</li> <li>Create <code>libs/data-layer</code> Nx library</li> <li>Setup migration infrastructure</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>PostgreSQL database running and accessible</li> <li>Prisma installed and configured: <code>prisma</code>, <code>@prisma/client</code></li> <li>Database connection established via <code>DATABASE_URL</code> env variable</li> <li>Nx library created for data layer: <code>libs/data-layer</code></li> <li>Migration commands work: <code>prisma migrate dev</code>, <code>prisma generate</code></li> </ul> </li> <li> <p>Dependencies: None</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Setup PostgreSQL (Docker compose or local install)</li> <li>Generate Nx library: <code>nx g @nx/node:library data-layer</code></li> <li>Install Prisma: <code>npm install prisma @prisma/client</code></li> <li>Initialize Prisma: <code>npx prisma init</code></li> <li>Configure database URL in <code>.env</code></li> <li>Test database connection</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-a002-design-and-implement-database-schema","title":"TASK-A002: Design and implement database schema","text":"<ul> <li>Summary: DATA-LAYER - Database Schema Design &amp; Migration</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: schema, database, data-model, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Design relational schema for Release, Epic, Story, Bug, Task entities with proper foreign keys, indexes, and constraints per technical specification.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Define Prisma schema for: <code>Release</code>, <code>Epic</code>, <code>Story</code>, <code>Bug</code>, <code>Task</code></li> <li>Add foreign key relationships: Epic\u2192Release, Story\u2192Epic, Bug/Task\u2192Story</li> <li>Create indexes on: <code>releaseId</code>, <code>epicId</code>, <code>storyId</code>, <code>statusCategory</code></li> <li>Add <code>updatedAt</code> timestamps for all entities</li> <li>Support edge case flags: <code>partial</code>, <code>multiLinked</code>, <code>unlinked</code>, <code>needsReview</code></li> <li>Include <code>delayDays</code> calculated field on Story</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Prisma schema file defines all 5 entities with correct field types</li> <li>Foreign keys enforce referential integrity</li> <li>Indexes created for query optimization</li> <li>Edge-case boolean flags included: <code>partial</code>, <code>multiLinked</code>, <code>unlinked</code></li> <li><code>updatedAt</code> timestamp auto-updates on modification</li> <li>Migration successfully applied: <code>prisma migrate dev</code></li> <li>Prisma Client generated with TypeScript types</li> </ul> </li> <li> <p>Dependencies: TASK-A001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Design schema in <code>prisma/schema.prisma</code></li> <li>Define Release model with fields</li> <li>Define Epic model with Release FK</li> <li>Define Story model with Epic FK and delay fields</li> <li>Define Bug model with Story FK and priority</li> <li>Define Task model with Story FK</li> <li>Add indexes for foreign keys and status fields</li> <li>Run migration: <code>prisma migrate dev --name init</code></li> <li>Generate Prisma Client</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#core-implementation","title":"\ud83d\udd27 Core Implementation","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-b001-implement-release-ingestion-service","title":"TASK-B001: Implement Release ingestion service","text":"<ul> <li>Summary: DATA-LAYER - Release Ingestion from JIRA-CLIENT</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: ingestion, releases, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Build ingestion service to consume Release DTOs from JIRA-CLIENT and perform idempotent upserts into database with audit logging.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Create <code>IngestionService</code> in data-layer module</li> <li>Implement <code>ingestReleases(projectId: string)</code> method</li> <li>Call JIRA-CLIENT <code>getVersions()</code> to fetch releases</li> <li>Perform idempotent upsert: update if exists, insert if new</li> <li>Use <code>id</code> (Jira version ID) as primary key</li> <li>Log ingestion run: start time, count, errors</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>ingestReleases()</code> fetches releases via JIRA-CLIENT</li> <li>Upsert logic correctly updates existing releases</li> <li>New releases inserted without duplicates</li> <li><code>updatedAt</code> timestamp updated on each run</li> <li>Audit log entry created with count and duration</li> <li>Idempotent: running multiple times doesn't create duplicates</li> </ul> </li> <li> <p>Dependencies: TASK-A002, JIRA-CLIENT TASK-B001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>IngestionService</code> class</li> <li>Inject JIRA-CLIENT dependency</li> <li>Implement <code>ingestReleases()</code> method</li> <li>Build upsert logic with Prisma</li> <li>Add ingestion audit logging</li> <li>Write unit tests with mocked JIRA-CLIENT</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-b002-implement-epic-ingestion-with-release-association","title":"TASK-B002: Implement Epic ingestion with release association","text":"<ul> <li>Summary: DATA-LAYER - Epic Ingestion with Release Linking</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: ingestion, epics, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Ingest Epic DTOs from JIRA-CLIENT, associate with releases, handle spanning epics (partial flag), and perform idempotent upserts.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>ingestEpics(releaseId: string)</code> method</li> <li>Fetch Epics via JIRA-CLIENT <code>searchIssues()</code> for target release</li> <li>Map Epic DTO to database entity</li> <li>Set <code>releaseId</code> foreign key</li> <li>Detect spanning epics: mark <code>partial = true</code> if Epic has multiple fixVersions</li> <li>Upsert Epics by <code>id</code> (Jira issue key)</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>ingestEpics()</code> fetches epics for specific release</li> <li>Epic records correctly linked to Release via <code>releaseId</code></li> <li><code>partial</code> flag set when Epic spans multiple releases</li> <li>Idempotent upserts preserve existing data</li> <li>Audit log includes epic count and errors</li> <li>Unit tests verify spanning epic detection</li> </ul> </li> <li> <p>Dependencies: TASK-B001, JIRA-CLIENT TASK-B002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Implement <code>ingestEpics()</code> method</li> <li>Build spanning epic detection logic</li> <li>Perform upsert with release association</li> <li>Add audit logging</li> <li>Write unit tests with edge cases</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-b003-implement-story-ingestion-with-epic-linking","title":"TASK-B003: Implement Story ingestion with epic linking","text":"<ul> <li>Summary: DATA-LAYER - Story Ingestion with Epic Association</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: ingestion, stories, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Ingest Story DTOs from JIRA-CLIENT, link to Epics, handle multi-linked and orphaned stories, calculate delay days, and perform idempotent upserts.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>ingestStories(releaseId: string)</code> method</li> <li>Fetch Stories via JIRA-CLIENT <code>searchIssues()</code> for target release</li> <li>Link Stories to Epics via <code>epicId</code> foreign key</li> <li>Mark <code>unlinked = true</code> for orphaned Stories (no Epic link)</li> <li>Mark <code>multiLinked = true</code> for Stories linked to multiple Epics</li> <li>Calculate <code>delayDays</code>: if <code>dueDate &lt; now</code> and <code>statusCategory != 'Done'</code>, compute days overdue</li> <li>Upsert Stories by <code>id</code> (Jira issue key)</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>ingestStories()</code> fetches stories for specific release</li> <li>Stories correctly linked to Epics via <code>epicId</code></li> <li>Orphaned stories marked with <code>unlinked = true</code></li> <li>Multi-linked stories marked with <code>multiLinked = true</code></li> <li><code>delayDays</code> accurately calculated for overdue incomplete stories</li> <li>Idempotent upserts handle status and delay changes</li> <li>Audit log includes story count and edge-case counts</li> </ul> </li> <li> <p>Dependencies: TASK-B002, JIRA-CLIENT TASK-B002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Implement <code>ingestStories()</code> method</li> <li>Build Epic linking logic with edge-case detection</li> <li>Implement delay calculation function</li> <li>Perform upsert with computed fields</li> <li>Add audit logging with edge-case metrics</li> <li>Write unit tests for orphaned/multi-linked stories</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-b004-implement-bug-and-task-ingestion-with-story-linking","title":"TASK-B004: Implement Bug and Task ingestion with story linking","text":"<ul> <li>Summary: DATA-LAYER - Bug &amp; Task Ingestion with Story Association</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 3</li> <li>Priority: Medium</li> <li>Labels: ingestion, bugs, tasks, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Ingest Bug and Task DTOs from JIRA-CLIENT, link to Stories, normalize priority and status, and perform idempotent upserts.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>ingestBugsAndTasks(releaseId: string)</code> method</li> <li>Fetch Bugs and Tasks via JIRA-CLIENT for stories in target release</li> <li>Link via <code>storyId</code> foreign key</li> <li>Normalize Bug priority: P0, P1, P2, P3, P4, Unclassified</li> <li>Normalize status to <code>statusCategory</code>: Open, In Progress, Closed</li> <li>Upsert by <code>id</code> (Jira issue key)</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>ingestBugsAndTasks()</code> fetches bugs and tasks for release stories</li> <li>Bugs and tasks correctly linked to Stories via <code>storyId</code></li> <li>Priority normalized to P0-P4 and Unclassified</li> <li>Status normalized to standard categories</li> <li>Idempotent upserts handle priority/status changes</li> <li>Audit log includes bug and task counts by priority/status</li> </ul> </li> <li> <p>Dependencies: TASK-B003, JIRA-CLIENT TASK-B003</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Implement <code>ingestBugsAndTasks()</code> method</li> <li>Build priority normalization mapper</li> <li>Build status normalization mapper</li> <li>Perform upsert with normalized fields</li> <li>Add audit logging</li> <li>Write unit tests for normalization</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#read-services-aggregation","title":"\ud83d\udd17 Read Services &amp; Aggregation","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-c001-implement-release-list-read-service","title":"TASK-C001: Implement release list read service","text":"<ul> <li>Summary: DATA-LAYER - Release List Query Service for APP-APIS</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 2</li> <li>Priority: High</li> <li>Labels: read-service, api, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Build read service to fetch paginated list of releases with basic filtering for APP-APIS <code>/api/releases</code> endpoint.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>listReleases(filters, pagination)</code> method</li> <li>Support filters: <code>query</code> (name search), <code>status</code>, <code>projectId</code></li> <li>Support pagination: <code>page</code>, <code>pageSize</code> (default 50, max 200)</li> <li>Return: <code>{ items: Release[], pageInfo: { page, pageSize, total } }</code></li> <li>Calculate total count for pagination metadata</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>listReleases()</code> returns paginated array of releases</li> <li>Query filter searches release names (case-insensitive)</li> <li>Status filter works correctly</li> <li>Pagination returns correct page of results</li> <li><code>pageInfo</code> includes accurate <code>total</code> count</li> <li>Unit tests verify filtering and pagination</li> </ul> </li> <li> <p>Dependencies: TASK-B001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>ReadService</code> class</li> <li>Implement <code>listReleases()</code> with Prisma query</li> <li>Add filtering logic for query and status</li> <li>Implement pagination with skip/take</li> <li>Calculate total count</li> <li>Write unit tests with sample data</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-c002-implement-hierarchy-read-service","title":"TASK-C002: Implement hierarchy read service","text":"<ul> <li>Summary: DATA-LAYER - Epic-Story Hierarchy Query Service</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: read-service, hierarchy, api, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Build read service to fetch Epic-Story hierarchy for a release with nested relationships and edge-case flags for APP-APIS <code>/api/release/:id/hierarchy</code> endpoint.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>getReleaseHierarchy(releaseId: string)</code> method</li> <li>Fetch Epics for release with nested Stories via Prisma <code>include</code></li> <li>Include edge-case flags: <code>partial</code>, <code>multiLinked</code>, <code>unlinked</code></li> <li>Return structure: <code>{ release: Release, epics: Epic[], notes?: string[] }</code></li> <li>Generate notes for edge cases: \"Some epics span multiple releases\", \"X orphaned stories\"</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>getReleaseHierarchy()</code> returns release with nested epics and stories</li> <li>Prisma query uses single query with <code>include</code> (no N+1)</li> <li>Edge-case flags correctly populated</li> <li>Notes array includes helpful messages for edge cases</li> <li>Orphaned stories included in separate <code>orphanedStories</code> array</li> <li>Unit tests verify nested structure and edge cases</li> </ul> </li> <li> <p>Dependencies: TASK-B003</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Implement <code>getReleaseHierarchy()</code> method</li> <li>Build nested Prisma query with includes</li> <li>Add orphaned stories handling</li> <li>Generate notes for edge cases</li> <li>Optimize query to avoid N+1 problem</li> <li>Write unit tests with complex hierarchies</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-c003-implement-signals-aggregation-service","title":"TASK-C003: Implement signals aggregation service","text":"<ul> <li>Summary: DATA-LAYER - KPIs and Signals Aggregation Service</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: read-service, aggregation, kpi, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Build aggregation service to calculate KPIs and group bugs/tasks by priority/status for APP-APIS <code>/api/release/:id/signals</code> endpoint.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>getReleaseSignals(releaseId: string)</code> method</li> <li>Calculate KPIs:<ul> <li>Overall completion % (done stories / total stories)</li> <li>Epics completed count (epics with statusCategory = 'Done')</li> <li>Stories on track (stories not delayed)</li> <li>Delayed items count (stories with delayDays &gt; 0)</li> <li>Open bugs count</li> <li>Open tasks count</li> </ul> </li> <li>Group bugs by priority: <code>{ P0: count, P1: count, ..., Unclassified: count }</code></li> <li>Group tasks by status: <code>{ Open: count, InProgress: count, Closed: count }</code></li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>getReleaseSignals()</code> returns KPIs with accurate calculations</li> <li>Bug counts grouped by priority (P0-P4, Unclassified)</li> <li>Task counts grouped by status category</li> <li>KPI percentages calculated correctly</li> <li>Efficient aggregation using Prisma aggregation functions</li> <li>Unit tests verify all KPI calculations</li> </ul> </li> <li> <p>Dependencies: TASK-B004</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Implement <code>getReleaseSignals()</code> method</li> <li>Build KPI calculation functions</li> <li>Implement bug priority grouping query</li> <li>Implement task status grouping query</li> <li>Calculate completion percentages</li> <li>Write unit tests for aggregations</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#testing-observability","title":"\u2728 Testing &amp; Observability","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-d001-implement-audit-logging-and-ingestion-tracking","title":"TASK-D001: Implement audit logging and ingestion tracking","text":"<ul> <li>Summary: DATA-LAYER - Audit Logging &amp; Ingestion Run Tracking</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 3</li> <li>Priority: Medium</li> <li>Labels: logging, audit, monitoring, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Create audit logging system to track ingestion runs with metrics, errors, and performance data.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Create <code>IngestionRun</code> entity to track runs</li> <li>Log: <code>runId</code>, <code>startTime</code>, <code>endTime</code>, <code>status</code>, <code>entityCounts</code>, <code>errorSummary</code></li> <li>Add structured logging with correlation IDs</li> <li>Track entity counts: releases, epics, stories, bugs, tasks ingested</li> <li>Track edge-case counts: orphaned, multi-linked, delayed items</li> <li>Calculate ingestion duration</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>IngestionRun</code> records created for each ingestion</li> <li>Run ID used as correlation ID in all logs</li> <li>Entity counts accurately tracked and logged</li> <li>Error summary includes failure details</li> <li>Ingestion duration calculated and logged</li> <li>Structured logs compatible with log aggregation tools</li> </ul> </li> <li> <p>Dependencies: TASK-B004</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>IngestionRun</code> Prisma model</li> <li>Add migration for audit table</li> <li>Implement audit logging in ingestion service</li> <li>Add correlation ID tracking</li> <li>Track entity and edge-case counts</li> <li>Write unit tests for audit logging</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-d002-integration-and-end-to-end-testing","title":"TASK-D002: Integration and end-to-end testing","text":"<ul> <li>Summary: DATA-LAYER - Integration &amp; E2E Tests</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: testing, integration, e2e, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Create comprehensive integration test suite covering full ingestion pipeline and read services with test database.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Setup test PostgreSQL database</li> <li>Mock JIRA-CLIENT responses with sample DTOs</li> <li>Test full ingestion flow: releases \u2192 epics \u2192 stories \u2192 bugs/tasks</li> <li>Verify idempotency: run ingestion twice, check no duplicates</li> <li>Test read services with seeded data</li> <li>Test edge cases: orphaned stories, spanning epics, multi-linked stories</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Integration tests run against test database</li> <li>Full ingestion pipeline tested end-to-end</li> <li>Idempotency verified: duplicate runs safe</li> <li>Read services return correct data structures</li> <li>Edge cases validated: orphaned, spanning, multi-linked items</li> <li>Tests pass in CI/CD with Docker Postgres</li> </ul> </li> <li> <p>Dependencies: TASK-C003, TASK-D001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Setup test database with Docker</li> <li>Create mock JIRA-CLIENT data fixtures</li> <li>Write ingestion pipeline integration tests</li> <li>Test idempotency with duplicate runs</li> <li>Write read service integration tests</li> <li>Test edge-case handling</li> <li>Configure CI/CD with test database</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-d003-documentation-and-schema-reference","title":"TASK-D003: Documentation and schema reference","text":"<ul> <li>Summary: DATA-LAYER - Documentation &amp; Schema Reference</li> <li>Issue Type: Story</li> <li>Epic Link: DATA-LAYER Epic</li> <li>Story Points: 2</li> <li>Priority: Low</li> <li>Labels: documentation, data-layer</li> <li> <p>Components: DATA-LAYER</p> </li> <li> <p>Description:</p> <p>Write comprehensive documentation for data layer including schema reference, ingestion guide, and troubleshooting tips.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Document database schema with entity relationships</li> <li>Create ingestion pipeline usage guide</li> <li>Document read service APIs</li> <li>Add migration guide for schema changes</li> <li>Write troubleshooting guide for common issues</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>README.md</code> includes: setup, schema overview, ingestion guide</li> <li>Entity relationship diagram (ERD) included</li> <li>Read service API documented with examples</li> <li>Migration guide covers adding/modifying entities</li> <li>Troubleshooting covers: connection issues, migration errors, data quality</li> </ul> </li> <li> <p>Dependencies: TASK-D002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Write <code>README.md</code> with setup instructions</li> <li>Generate ERD from Prisma schema</li> <li>Document ingestion service API</li> <li>Document read service API</li> <li>Create migration guide</li> <li>Write troubleshooting guide</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#4-task-dependencies-sequencing","title":"4. Task Dependencies &amp; Sequencing","text":"<pre><code>graph TD\n    A001[A001: DB Setup] --&gt; A002[A002: Schema Design]\n    A002 --&gt; B001[B001: Ingest Releases]\n    B001 --&gt; B002[B002: Ingest Epics]\n    B002 --&gt; B003[B003: Ingest Stories]\n    B003 --&gt; B004[B004: Ingest Bugs/Tasks]\n    B001 --&gt; C001[C001: Release List Service]\n    B003 --&gt; C002[C002: Hierarchy Service]\n    B004 --&gt; C003[C003: Signals Service]\n    B004 --&gt; D001[D001: Audit Logging]\n    C003 --&gt; D002[D002: Integration Tests]\n    D001 --&gt; D002\n    D002 --&gt; D003[D003: Documentation]\n\n    classDef foundation fill:#e1f5fe,stroke:#01579b\n    classDef core fill:#f3e5f5,stroke:#4a148c\n    classDef integration fill:#e8f5e8,stroke:#1b5e20\n    classDef polish fill:#fff3e0,stroke:#e65100\n\n    class A001,A002 foundation\n    class B001,B002,B003,B004 core\n    class C001,C002,C003 integration\n    class D001,D002,D003 polish</code></pre>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#5-parallel-development-opportunities","title":"5. Parallel Development Opportunities","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#what-can-be-built-simultaneously","title":"What Can Be Built Simultaneously:","text":"<ul> <li>After B001: C001 can start while B002 progresses</li> <li>After B004: C003 and D001 can start in parallel</li> <li>Sequential ingestion: B001 \u2192 B002 \u2192 B003 \u2192 B004 must be sequential due to foreign key dependencies</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#critical-path","title":"Critical Path:","text":"<p>A001 \u2192 A002 \u2192 B001 \u2192 B002 \u2192 B003 \u2192 B004 \u2192 C003 \u2192 D002 \u2192 D003</p>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#6-risk-mitigation-tasks","title":"6. Risk Mitigation Tasks","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#technical-risks","title":"Technical Risks:","text":"<ul> <li>Risk DATA-R1 (Data Hygiene): <code>needsReview</code> flags and empty-state handling in TASK-B003, TASK-B004</li> <li>Risk DATA-R2 (Large Payloads): Pagination and batch transactions in ingestion pipeline</li> <li>Risk DATA-R3 (Schema Evolution): Migration strategy and versioned DTOs in TASK-A002</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#7-definition-of-done","title":"7. Definition of Done","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#task-completion-criteria","title":"Task Completion Criteria:","text":"<ul> <li>\u2705 All acceptance criteria met</li> <li>\u2705 Unit tests written and passing (&gt;80% coverage)</li> <li>\u2705 Code review completed</li> <li>\u2705 Integration tests passing (where applicable)</li> <li>\u2705 Database migrations applied successfully</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#component-completion-criteria","title":"Component Completion Criteria:","text":"<ul> <li>\u2705 All tasks completed per definition of done</li> <li>\u2705 Technical specification requirements met</li> <li>\u2705 Integration with JIRA-CLIENT and APP-APIS verified</li> <li>\u2705 Idempotent ingestion pipeline operational</li> <li>\u2705 Read services return correct data structures</li> <li>\u2705 Ready for APP-APIS consumption</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#8-estimation-summary","title":"8. Estimation Summary","text":"Category Task Count Total Effort Duration (days) Foundation &amp; Setup 2 8 points 3-4 days Core Implementation 4 14 points 6-8 days Read Services &amp; Aggregation 3 12 points 5-7 days Testing &amp; Observability 3 10 points 4-6 days TOTAL 12 44 points 18-25 days"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#9-traceability-matrix","title":"9. Traceability Matrix","text":"Task ID Technical Spec Section Functional Requirements Business Value A001 Section 5.1 Setup/Infrastructure Development efficiency A002 Section 4.1 FR-DATA-001 Data integrity foundation B001 Section 3.1 FR-DATA-002 Release data persistence B002 Section 3.1 FR-DATA-002 Epic data persistence B003 Section 3.1, 4.1 FR-DATA-002, FR-DATA-003 Story data with edge cases B004 Section 3.1 FR-DATA-002, FR-DATA-003 Quality signal data C001 Section 3.2 FR-DATA-004 Release listing API C002 Section 3.2 FR-DATA-004 Hierarchy visualization C003 Section 3.2 FR-DATA-004 KPI aggregation D001 Section 9.1 FR-DATA-005 Audit trail D002 Section 10.2 Testing Strategy Quality assurance D003 Section 11.1 Documentation Developer experience"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#10-implementation-notes","title":"10. Implementation Notes","text":""},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#development-best-practices","title":"Development Best Practices:","text":"<ul> <li>Use Prisma migrations for all schema changes</li> <li>Implement idempotent upserts using <code>upsert()</code> with unique constraints</li> <li>Use transactions for multi-entity operations</li> <li>Optimize queries to avoid N+1 problems with <code>include</code></li> <li>Use Prisma relation modes for referential integrity</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#quality-gates","title":"Quality Gates:","text":"<ul> <li>Unit test coverage minimum 80%</li> <li>Integration tests pass with test database</li> <li>No database migration rollbacks in production</li> <li>All read services tested with realistic data volumes</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-development-tasks/#communication-plan","title":"Communication Plan:","text":"<ul> <li>Daily standup updates on ingestion pipeline progress</li> <li>Demo working ingestion after TASK-B004</li> <li>Share schema ERD with team after TASK-A002</li> <li>Escalate data quality issues discovered during ingestion</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/","title":"PRD - Phase 1","text":""},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#1-module-overview","title":"1. Module Overview","text":"<ul> <li>Purpose: Persist normalized Jira data into HALDI\u2019s database via an idempotent ingestion pipeline with auditability.</li> <li>Business Value: Provides reliable, queryable data to power hierarchy views, KPIs, and signals with minimal manual effort.</li> <li>User Value: Indirect\u2014users experience fast, consistent UI backed by correct data.</li> <li>Module Type: Core</li> <li>Phase 1 Scope: Minimal schemas (Release, Epic, Story, Bug, Task), idempotent upserts, ingestion jobs with audit logs, retries/backoff, basic integrity checks for release membership.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#2-scope-boundaries","title":"2. Scope &amp; Boundaries","text":"<ul> <li>In Scope:<ul> <li>Define DB schemas and indexes for Release/Epic/Story/Bug/Task with associations.</li> <li>Implement ingestion job(s) that consume normalized outputs from JIRA-CLIENT.</li> <li>Idempotent upsert behavior using item keys and timestamps.</li> <li>Audit logs per run: run ID, start/end, counts, successes/failures.</li> <li>Retry with exponential backoff on transient source errors.</li> <li>Integrity checks: validate Epic \u2192 Story links, release membership flags.</li> </ul> </li> <li>Out of Scope:<ul> <li>Public API endpoints (APP-APIS) for UI consumption.</li> <li>Advanced analytics or forecasting.</li> <li>Report generation.</li> </ul> </li> <li>Dependencies:<ul> <li>JIRA-CLIENT normalized payloads.</li> <li>Database environment available (dev/test).</li> </ul> </li> <li>Dependents:<ul> <li>APP-APIS reads these persisted entities.</li> <li>USER-INTERFACE relies on APP-APIS fed by this data.</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#3-user-personas-contexts","title":"3. User Personas &amp; Contexts","text":"<ul> <li>Persona: Backend Engineer / Data Engineer</li> <li>Goals: Persist clean data reliably and audit ingestion runs.</li> <li>Context: MVP foundation; correctness and traceability prioritized.</li> <li>Pain Points: Duplicates, inconsistent associations, partial failures.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#4-user-stories","title":"4. User Stories","text":"<ul> <li>US-DATA-LAYER-001: As an engineer, I want idempotent upserts so that repeated ingestion does not create duplicates.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given repeated runs, when upserting, then entity counts remain consistent and duplicates are prevented via keys.</li> </ul> </li> <li>US-DATA-LAYER-002: As an engineer, I want audit logs so that I can track ingestion outcomes.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given a run, when completed, then logs include run ID, start/end, counts, failures with reasons.</li> </ul> </li> <li>US-DATA-LAYER-003: As an engineer, I want basic integrity checks so that associations and release membership are trustworthy.</li> <li>Priority: Medium</li> <li>Acceptance Criteria:<ul> <li>Given ingested data, when validating, then Epic \u2192 Story links and release flags are verified; anomalies flagged.</li> </ul> </li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#5-functional-requirements","title":"5. Functional Requirements","text":"<ul> <li>FR-DATA-LAYER-001: Define schemas for Release/Epic/Story/Bug/Task with fields: keys, summary, status, types, associations, fixVersion/labels.</li> <li>Related Project FR: FR-018.</li> <li>Module Context: Storage foundation.</li> <li>FR-DATA-LAYER-002: Implement idempotent upsert ingestion using keys and <code>updated</code> timestamps.</li> <li>Related Project FR: FR-018 AC2.</li> <li>Module Context: Prevent duplication and ensure freshness.</li> <li>FR-DATA-LAYER-003: Add retries with exponential backoff for transient source/client errors.</li> <li>Related Project FR: FR-018 AC3.</li> <li>Module Context: Resilience.</li> <li>FR-DATA-LAYER-004: Write audit logs per run with run ID, timings, item counts, successes/failures.</li> <li>Related Project FR: FR-018 AC4.</li> <li>Module Context: Observability.</li> <li>FR-DATA-LAYER-005: Respect rate limits and paginate source data without exceeding quotas.</li> <li>Related Project FR: FR-018 AC5.</li> <li>Module Context: Compliance.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#6-business-rules-logic","title":"6. Business Rules &amp; Logic","text":"<ul> <li>BR-DATA-LAYER-001: Upserts must be atomic per batch to avoid partial writes.</li> <li>Example: Use transactions per batch; rollback on failures.</li> <li>Edge Cases: Split batches if exceeding transaction limits.</li> <li>BR-DATA-LAYER-002: Associations must maintain referential integrity.</li> <li>Example: Stories reference parent Epics; orphan handling flagged.</li> <li>Edge Cases: Temporarily store unlinked items for later resolution.</li> <li>BR-DATA-LAYER-003: Release membership is determined primarily by <code>fixVersion</code>, falling back to labels.</li> <li>Example: Multiple versions mapped; choose active target per run context.</li> <li>Edge Cases: Missing fields tracked as anomalies.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#7-user-interface-requirements","title":"7. User Interface Requirements","text":"<ul> <li>None (headless). Optional admin console/log viewer in future.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#8-data-requirements","title":"8. Data Requirements","text":"<ul> <li>Input Data: Normalized entities from JIRA-CLIENT.</li> <li>Output Data: Persisted entities and associations suitable for APP-APIS.</li> <li>Stored Data: Release/Epic/Story/Bug/Task, ingestion audit logs.</li> <li>Lifecycle: Retain audit logs for \u2265 30 days; entities updated per run.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#9-integration-specifications","title":"9. Integration Specifications","text":"<ul> <li>APIs/Interfaces: Ingestion service consumes client outputs; DB connections.</li> <li>Events: None in Phase 1.</li> <li>Data Flow: Client \u2192 Ingestion \u2192 DB.</li> <li>Error Handling: Retries/backoff, transactional rollbacks, anomaly flags.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#10-performance-quality-requirements","title":"10. Performance &amp; Quality Requirements","text":"<ul> <li>Performance: Ingest typical releases in \u2264 5 minutes; batch sizes tuned.</li> <li>Reliability: Idempotent; recoverable after partial failures; consistent counts.</li> <li>Security: DB credentials stored securely; logs redact sensitive data.</li> <li>Usability: Clear audit logs and counters for run introspection.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#11-success-metrics","title":"11. Success Metrics","text":"<ul> <li>Business Metrics: \u226595% release mapping accuracy reflected in DB.</li> <li>User Metrics: UI loads data consistently with minimal anomalies.</li> <li>Technical Metrics: Zero duplicate entities; \u2264 1% ingestion error rate; audit logs for 100% runs.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#12-edge-cases-error-scenarios","title":"12. Edge Cases &amp; Error Scenarios","text":"<ul> <li>Error Case 1: Source client transient failures mid-batch.</li> <li>User Experience: N/A.</li> <li>System Behavior: Retry and resume; log partial progress.</li> <li>Edge Case 1: Inconsistent Epic \u2192 Story linkages.</li> <li>Business Logic: Flag and store in anomaly table for PM review pathways.</li> <li>User Impact: UI later shows \"Needs Review\" markers via APP-APIS.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Enhancement 1: Differential ingestion based on changelog snapshots.</li> <li>Enhancement 2: Admin dashboard for run monitoring and anomaly triage.</li> <li>Enhancement 3: Data retention policies for historical analytics.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#14-acceptance-criteria-summary","title":"14. Acceptance Criteria Summary","text":"<ul> <li> Schemas created with keys, associations, and indexes.</li> <li> Idempotent upsert ingestion implemented.</li> <li> Audit logs per run captured and queryable.</li> <li> Retries/backoff and transactional integrity enforced.</li> <li> Integrity checks flag anomalies (links/membership).</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-product-spec/#15-open-questions","title":"15. Open Questions","text":"<ul> <li>Question 1: Which database (Postgres, MongoDB, etc.) and schema conventions will be standard?</li> <li>Question 2: What retention period and detail level for ingestion audit logs?</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/","title":"TRD - Phase 1","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#1-component-overview","title":"1. Component Overview","text":"<ul> <li>Purpose: Persist and serve normalized entities (Release, Epic, Story, Bug, Task) populated from Jira via ingestion jobs for APP-APIS and UI.</li> <li>Scope: Define schemas, mappers, ingestion pipeline (read from JIRA-CLIENT, write to DB), idempotent upserts, and basic audit logging.</li> <li>Phase 1 Scope: Minimal relational schema, ingestion jobs with pagination/backoff, normalization rules, and read services for APP-APIS.</li> <li>Dependencies: JIRA-CLIENT (normalized DTOs), database runtime.</li> <li>Dependents: APP-APIS (reads data), REPORTING (reads aggregated data).</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#2-functional-requirements","title":"2. Functional Requirements","text":"<ul> <li>FR-DATA-001: Define canonical schemas for Release, Epic, Story, Bug, Task.</li> <li>FR-DATA-002: Implement ingestion jobs that upsert entities idempotently.</li> <li>FR-DATA-003: Normalize Jira payloads (statuses, memberships, links, priorities).</li> <li>FR-DATA-004: Provide read services for APP-APIS endpoints.</li> <li>FR-DATA-005: Log ingestion runs with counts and error summaries.</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#3-component-interface","title":"3. Component Interface","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#31-ingestion-api-internal","title":"3.1 Ingestion API (internal)","text":"<ul> <li><code>ingestReleases(projectId)</code> \u2192 upsert Releases</li> <li><code>ingestEpics(releaseId)</code> \u2192 upsert Epics</li> <li><code>ingestStories(epicId|releaseId)</code> \u2192 upsert Stories</li> <li><code>ingestSignals(releaseId)</code> \u2192 upsert Bugs/Tasks linked to Stories</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#32-read-services-for-app-apis","title":"3.2 Read Services (for APP-APIS)","text":"<ul> <li><code>listReleases(filters, pagination)</code> \u2192 paginated <code>Release</code></li> <li><code>getReleaseHierarchy(releaseId)</code> \u2192 <code>Epic</code> with nested <code>Story</code></li> <li><code>getReleaseSignals(releaseId)</code> \u2192 KPIs + grouped Bugs/Tasks; provide minimal aggregation functions (counts by status/priority, delayed items)</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#33-contracts","title":"3.3 Contracts","text":"<ul> <li>Inputs: Normalized DTOs from JIRA-CLIENT; identifiers and filters</li> <li>Outputs: Entities and aggregates; stable shapes used by APP-APIS</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#4-data-model","title":"4. Data Model","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#41-data-storage","title":"4.1 Data Storage","text":"<ul> <li>Storage Type: Relational DB (Postgres/MySQL acceptable); Phase 1 assumptions</li> <li>Data Schema: <pre><code>CREATE TABLE releases (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  status TEXT NOT NULL,\n  project_id TEXT NOT NULL,\n  updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\nCREATE TABLE epics (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  status_category TEXT NOT NULL,\n  release_id TEXT REFERENCES releases(id),\n  partial BOOLEAN DEFAULT FALSE,\n  updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\nCREATE TABLE stories (\n  id TEXT PRIMARY KEY,\n  epic_id TEXT REFERENCES epics(id),\n  name TEXT NOT NULL,\n  status_category TEXT NOT NULL,\n  assignee TEXT,\n  due_date DATE,\n  delay_days INTEGER,\n  multi_linked BOOLEAN DEFAULT FALSE,\n  unlinked BOOLEAN DEFAULT FALSE,\n  updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\nCREATE TABLE bugs (\n  id TEXT PRIMARY KEY,\n  story_id TEXT REFERENCES stories(id),\n  priority TEXT NOT NULL,\n  status_category TEXT NOT NULL,\n  updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\nCREATE TABLE tasks (\n  id TEXT PRIMARY KEY,\n  story_id TEXT REFERENCES stories(id),\n  status_category TEXT NOT NULL,\n  updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_epics_release ON epics(release_id);\nCREATE INDEX idx_stories_epic ON stories(epic_id);\nCREATE INDEX idx_bugs_story ON bugs(story_id);\nCREATE INDEX idx_tasks_story ON tasks(story_id);\n\n-- Optional aggregation views (Phase 1 convenience)\n-- KPIs per release: counts and status breakdowns\n-- Implement as service-level aggregates if DB views are deferred\n</code></pre></li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#42-data-flow","title":"4.2 Data Flow","text":"<pre><code>flowchart TD\n    A[JIRA-CLIENT DTOs] --&gt; B[Normalization Mappers]\n    B --&gt; C[Idempotent Upserts]\n    C --&gt; D[Relational DB]\n    D --&gt; E[Read Services]\n    E --&gt; F[APP-APIS]</code></pre>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#43-data-validation","title":"4.3 Data Validation","text":"<ul> <li>Input Validation: Ensure required fields; map unknowns to safe defaults; sanitize text</li> <li>Business Rules: Status to category mapping; release membership via fixVersions/labels</li> <li>Data Integrity: Foreign key constraints; updated_at tracking; unique IDs</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#5-technology-stack","title":"5. Technology Stack","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#51-core-technologies","title":"5.1 Core Technologies","text":"<ul> <li>Programming Language: TypeScript/Nest data services</li> <li>ORM/DB: Prisma/TypeORM/Knex (choose one); Postgres recommended</li> <li>Jobs: Node/Nest cron or task runner</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#52-technology-rationale","title":"5.2 Technology Rationale","text":"<ul> <li>Why These Choices: Rapid schema iteration and typed queries; Nest integration</li> <li>Alternatives Considered: Raw SQL; slower iteration, fewer safety nets</li> <li>Trade-offs: ORM abstraction cost; acceptable for MVP</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#6-integration-design","title":"6. Integration Design","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#61-dependency-integration","title":"6.1 Dependency Integration","text":"<ul> <li>JIRA-CLIENT: Consume normalized DTOs; batch commit per page</li> <li>APP-APIS: Expose read aggregation functions to controllers</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#62-service-integration","title":"6.2 Service Integration","text":"<ul> <li>External Services: None</li> <li>Authentication: N/A (internal DB)</li> <li>Rate Limiting: N/A (DB)</li> <li>Fallback Strategies: Retry transaction on transient DB errors</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#71-requirements","title":"7.1 Requirements","text":"<ul> <li>Response Time: Read queries \u2264 3s typical for releases with \u2264 50 epics</li> <li>Throughput: Ingestion completes within 10 minutes typical</li> <li>Scalability: Indexes and pagination</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#72-strategies","title":"7.2 Strategies","text":"<ul> <li>Caching: Defer; consider query caching later</li> <li>Database Optimization: Appropriate indexes; denormalized aggregates optional</li> <li>Resource Management: Batch upserts; transaction boundaries per page</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#8-security-design","title":"8. Security Design","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#81-requirements","title":"8.1 Requirements","text":"<ul> <li>Authentication: DB credentials secured via env/secret manager</li> <li>Authorization: App-level controls (internal)</li> <li>Data Protection: No sensitive data persisted beyond required fields</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#82-implementation","title":"8.2 Implementation","text":"<ul> <li>Encryption: TLS to DB where applicable</li> <li>Sanitization: Input sanitization on text; avoid SQL injection</li> <li>Audit Logging: Ingestion run logs and counts</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#9-monitoring-observability","title":"9. Monitoring &amp; Observability","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#91-logging","title":"9.1 Logging","text":"<ul> <li>Log Levels: Info for batches, Error on failures</li> <li>Log Format: Structured logs with run IDs</li> <li>Sensitive Data: Avoid logging PII</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#92-metrics","title":"9.2 Metrics","text":"<ul> <li>Performance Metrics: Rows ingested, latency, failures</li> <li>Business Metrics: Release/epic/story counts per run</li> <li>Alerting: Optional thresholds on failure/latency</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#10-testing-strategy","title":"10. Testing Strategy","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#101-unit-testing","title":"10.1 Unit Testing","text":"<ul> <li>Coverage: Mappers and upsert logic</li> <li>Key Test Cases: Idempotency, foreign key constraints, status mapping</li> <li>Mock Dependencies: Mock DTOs from JIRA-CLIENT</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#102-integration-testing","title":"10.2 Integration Testing","text":"<ul> <li>Points: DB migrations, ingestion end-to-end</li> <li>Test Data: Synthetic sample sets with edge cases</li> <li>Environment: Test DB with migrations</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#11-deployment-considerations","title":"11. Deployment Considerations","text":""},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#111-requirements","title":"11.1 Requirements","text":"<ul> <li>Infrastructure: Managed Postgres and Nest job runner</li> <li>Configuration: DB URL, credentials, page sizes</li> <li>Secrets: Stored securely in env/secret manager</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#112-strategy","title":"11.2 Strategy","text":"<ul> <li>Build: Apply migrations; deploy data services</li> <li>Deploy: Rolling updates; job scheduling</li> <li>Rollback: Migration rollback strategy</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#12-risk-mitigation","title":"12. Risk Mitigation","text":"<ul> <li>Risk R1 (Data Hygiene): <code>needsReview</code> flags and empty-state guidance</li> <li>Risk R2 (Large Payloads): Pagination and batch transactions</li> <li>Risk R3 (Schema Evolution): Migrations and versioned DTOs</li> </ul>"},{"location":"implementation/DATA-LAYER/phase-1-technical-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Extensibility: Aggregation tables for KPIs; materialized views</li> <li>Migration Path: Introduce soft deletes and changelog tables</li> <li>Deprecation Strategy: Versioned schemas and data services</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/","title":"Tasks - Phase 1","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#1-task-overview","title":"1. Task Overview","text":"<ul> <li>Component: JIRA-CLIENT</li> <li>Phase: 1</li> <li>Technical Spec: phase-1-technical-spec.md</li> <li>Total Estimated Effort: 21 story points</li> <li>Implementation Order: 4 task groups in sequence</li> <li>Phase 1 Scope: Secure Jira API authentication, core entity fetching (Releases, Epics, Stories, Bugs, Tasks), pagination with rate-limit handling, and normalized DTO output for DATA-LAYER ingestion</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#2-task-categories","title":"2. Task Categories","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#category-a-foundation-setup","title":"Category A: Foundation &amp; Setup","text":"<p>Core authentication and HTTP client infrastructure</p>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#category-b-core-implementation","title":"Category B: Core Implementation","text":"<p>Entity fetching and JQL query construction</p>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#category-c-integration-resilience","title":"Category C: Integration &amp; Resilience","text":"<p>Pagination, rate-limiting, retries, and normalization</p>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#category-d-testing-documentation","title":"Category D: Testing &amp; Documentation","text":"<p>Comprehensive testing and integration documentation</p>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#3-detailed-task-breakdown","title":"3. Detailed Task Breakdown","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#foundation-setup","title":"\ud83d\udccb Foundation &amp; Setup","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-a001-setup-jira-client-module-and-dependencies","title":"TASK-A001: Setup Jira client module and dependencies","text":"<ul> <li>Summary: JIRA-CLIENT - Setup Module Structure &amp; Dependencies</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 2</li> <li>Priority: High</li> <li>Labels: setup, foundation, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Create NestJS module structure for Jira API client with core dependencies and configuration setup.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Create <code>libs/jira-client</code> folder structure in Nx workspace</li> <li>Install dependencies: <code>@nestjs/axios</code>, <code>axios</code>, <code>dotenv</code></li> <li>Setup module exports and barrel files</li> <li>Configure TypeScript paths in <code>tsconfig.base.json</code></li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Module structure created with proper Nx library setup</li> <li>Dependencies installed and verified in <code>package.json</code></li> <li>Module can be imported by other apps in workspace</li> <li>Basic module registration works in test context</li> </ul> </li> <li> <p>Dependencies: None</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Generate Nx library: <code>nx g @nx/node:library jira-client</code></li> <li>Install HTTP client dependencies</li> <li>Create barrel exports in <code>index.ts</code></li> <li>Update workspace TypeScript paths</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-a002-implement-jira-authentication-and-configuration","title":"TASK-A002: Implement Jira authentication and configuration","text":"<ul> <li>Summary: JIRA-CLIENT - Authentication &amp; Config Management</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: authentication, security, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Build secure authentication mechanism for Jira Cloud API using API tokens with Basic Auth, configuration management for Jira base URL, and credential storage.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>JiraConfigService</code> with validation</li> <li>Support API token authentication (email + token via Basic Auth)</li> <li>Securely load credentials from environment variables</li> <li>Add request interceptor for auth headers</li> <li>Validate Jira base URL format</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Environment variables: <code>JIRA_BASE_URL</code>, <code>JIRA_EMAIL</code>, <code>JIRA_API_TOKEN</code></li> <li>Config validation throws error on missing/invalid credentials</li> <li>Auth headers automatically added to all requests</li> <li>No credentials logged or exposed in error messages</li> <li>Test connection endpoint verifies authentication</li> </ul> </li> <li> <p>Dependencies: TASK-A001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>JiraConfigService</code> with env validation</li> <li>Implement Basic Auth interceptor</li> <li>Add credential validation logic</li> <li>Create <code>testConnection()</code> method</li> <li>Write unit tests for auth interceptor</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#core-implementation","title":"\ud83d\udd27 Core Implementation","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-b001-implement-releases-and-versions-fetching","title":"TASK-B001: Implement releases and versions fetching","text":"<ul> <li>Summary: JIRA-CLIENT - Fetch Releases (Versions) from Jira</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: api, releases, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Build API methods to fetch Jira versions (releases) for projects and map them to normalized Release DTOs with project association.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>getVersions(projectKey: string)</code> method</li> <li>Call Jira API: <code>GET /rest/api/3/project/{projectKey}/versions</code></li> <li>Map Jira versions to internal <code>ReleaseDTO</code> format</li> <li>Extract <code>id</code>, <code>name</code>, <code>released</code>, <code>releaseDate</code> fields</li> <li>Handle projects with no versions (empty array)</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>getVersions()</code> returns array of <code>ReleaseDTO</code> objects</li> <li>DTO includes: <code>id</code>, <code>name</code>, <code>status</code>, <code>projectId</code></li> <li>Empty array returned for projects without versions</li> <li>Error handling for invalid project keys</li> <li>Unit tests verify DTO mapping correctness</li> </ul> </li> <li> <p>Dependencies: TASK-A002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>ReleaseDTO</code> interface</li> <li>Implement <code>getVersions()</code> API call</li> <li>Build DTO mapper function</li> <li>Handle empty/null responses</li> <li>Write unit tests with mocked responses</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-b002-implement-epic-and-story-fetching-with-jql","title":"TASK-B002: Implement Epic and Story fetching with JQL","text":"<ul> <li>Summary: JIRA-CLIENT - Fetch Epics and Stories via JQL Search</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: api, epics, stories, jql, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Build JQL search functionality to fetch Epics and Stories for a target release, resolve Epic-Story relationships via Epic Link field, and normalize to internal DTOs.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement <code>searchIssues(jql: string, options)</code> method</li> <li>Call Jira API: <code>POST /rest/api/3/search</code></li> <li>Build JQL queries for: Epics by fixVersion, Stories by fixVersion</li> <li>Resolve Epic Link custom field (default: <code>customfield_10014</code>)</li> <li>Map to <code>EpicDTO</code> and <code>StoryDTO</code> with relationships</li> <li>Extract: <code>key</code>, <code>summary</code>, <code>status</code>, <code>statusCategory</code>, <code>assignee</code>, <code>duedate</code></li> <li>Handle spanning Epics (partial flag), orphaned Stories (unlinked flag)</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>searchIssues()</code> executes JQL and returns normalized DTOs</li> <li>Epic Link field ID configurable via environment variable</li> <li>DTOs include: <code>id</code>, <code>name</code>, <code>statusCategory</code>, <code>epicId</code> (for stories)</li> <li>Edge cases handled: missing Epic Link, multiple fixVersions</li> <li>Status mapped to category: <code>To Do</code>, <code>In Progress</code>, <code>Done</code></li> <li>Unit tests verify DTO mapping and edge cases</li> </ul> </li> <li> <p>Dependencies: TASK-A002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>EpicDTO</code> and <code>StoryDTO</code> interfaces</li> <li>Implement <code>searchIssues()</code> with JQL support</li> <li>Build JQL query helpers for releases</li> <li>Implement Epic Link field resolution</li> <li>Map status to statusCategory</li> <li>Handle spanning/orphaned edge cases</li> <li>Write comprehensive unit tests</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-b003-implement-bug-and-task-fetching-with-issue-links","title":"TASK-B003: Implement Bug and Task fetching with issue links","text":"<ul> <li>Summary: JIRA-CLIENT - Fetch Bugs and Tasks Linked to Stories</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 3</li> <li>Priority: Medium</li> <li>Labels: api, bugs, tasks, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Fetch Bugs and Tasks linked to Stories via issue links or subtasks, normalize priority and status fields, and provide grouped DTOs by Story ID.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Extend <code>searchIssues()</code> to fetch Bugs (issuetype = Bug) and Tasks (issuetype = Task)</li> <li>Use JQL to find issues linked to target Stories</li> <li>Extract <code>priority</code> field for Bugs (P0-P4 mapping)</li> <li>Map status to <code>statusCategory</code> for both Bugs and Tasks</li> <li>Build <code>BugDTO</code> and <code>TaskDTO</code> with <code>storyId</code> association</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>searchIssues()</code> can filter by issuetype (Bug, Task)</li> <li>DTOs include: <code>id</code>, <code>storyId</code>, <code>priority</code> (Bugs only), <code>statusCategory</code></li> <li>Priority mapped to standard levels: P0, P1, P2, P3, P4, Unclassified</li> <li>Status mapped to category: Open, In Progress, Closed</li> <li>Unit tests verify DTO mapping and priority normalization</li> </ul> </li> <li> <p>Dependencies: TASK-B002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create <code>BugDTO</code> and <code>TaskDTO</code> interfaces</li> <li>Implement JQL for linked issues</li> <li>Build priority mapping logic (Highest\u2192P0, High\u2192P1, etc.)</li> <li>Map task/bug status to categories</li> <li>Write unit tests for priority/status mapping</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#integration-resilience","title":"\ud83d\udd17 Integration &amp; Resilience","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-c001-implement-pagination-and-cursor-management","title":"TASK-C001: Implement pagination and cursor management","text":"<ul> <li>Summary: JIRA-CLIENT - Pagination Support for API Calls</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 3</li> <li>Priority: High</li> <li>Labels: pagination, performance, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Add pagination support to handle large result sets from Jira API using <code>startAt</code> and <code>maxResults</code> parameters with cursor-based iteration.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Implement pagination options: <code>{ startAt, maxResults, maxPages }</code></li> <li>Default <code>maxResults</code> = 50, max = 100</li> <li>Iterate through pages using <code>startAt</code> cursor</li> <li>Return aggregated results or yield pages via generator</li> <li>Track <code>total</code> results and calculate <code>isLastPage</code></li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li><code>searchIssues()</code> accepts pagination options</li> <li>Automatically fetches all pages up to <code>maxPages</code> limit</li> <li>Returns consolidated array of all fetched items</li> <li>Pagination metadata included: <code>page</code>, <code>total</code>, <code>nextStartAt</code></li> <li>Unit tests verify multi-page fetching logic</li> </ul> </li> <li> <p>Dependencies: TASK-B002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Add pagination options to <code>searchIssues()</code> signature</li> <li>Implement page iteration logic with <code>startAt</code> cursor</li> <li>Build result aggregation function</li> <li>Add pagination metadata to responses</li> <li>Write tests for multi-page scenarios</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-c002-implement-rate-limit-handling-and-retry-logic","title":"TASK-C002: Implement rate-limit handling and retry logic","text":"<ul> <li>Summary: JIRA-CLIENT - Rate Limit Detection &amp; Exponential Backoff</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 5</li> <li>Priority: High</li> <li>Labels: resilience, rate-limiting, error-handling, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Detect Jira API rate limits (HTTP 429), implement exponential backoff with jitter, and add retry logic for transient failures with configurable max retries.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Detect HTTP 429 (rate limited) and 503 (service unavailable) responses</li> <li>Implement exponential backoff: 1s, 2s, 4s, 8s with random jitter</li> <li>Respect <code>Retry-After</code> header from Jira responses</li> <li>Max retries: 3 (configurable via env)</li> <li>Log retry attempts with correlation ID</li> <li>Fail fast on non-retryable errors (401, 403, 404)</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>HTTP interceptor detects rate-limit responses (429, 503)</li> <li>Exponential backoff implemented with jitter randomization</li> <li><code>Retry-After</code> header respected when present</li> <li>Non-retryable errors fail immediately without retries</li> <li>Retry attempts logged with request correlation ID</li> <li>Unit tests verify backoff timing and retry limits</li> </ul> </li> <li> <p>Dependencies: TASK-A002</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create HTTP response interceptor for error detection</li> <li>Implement exponential backoff calculator with jitter</li> <li>Add <code>Retry-After</code> header parsing</li> <li>Configure max retries via environment variable</li> <li>Add structured logging for retry attempts</li> <li>Write unit tests for retry logic and backoff timing</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-c003-build-dto-normalization-and-data-validation","title":"TASK-C003: Build DTO normalization and data validation","text":"<ul> <li>Summary: JIRA-CLIENT - DTO Normalization &amp; Validation Layer</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 3</li> <li>Priority: Medium</li> <li>Labels: data-quality, normalization, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Create normalization layer to transform raw Jira responses into consistent DTOs with validation, default value handling, and edge-case flagging.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Build normalization functions for each DTO type</li> <li>Map Jira <code>status.statusCategory.name</code> \u2192 <code>statusCategory</code></li> <li>Calculate <code>delayDays</code> from <code>duedate</code> vs current date</li> <li>Mark <code>needsReview</code> flag for missing/invalid data</li> <li>Handle null/undefined fields with safe defaults</li> <li>Validate required fields: <code>id</code>, <code>name</code>, <code>status</code></li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>All DTOs pass through normalization layer before returning</li> <li>Status consistently mapped to: <code>To Do</code>, <code>In Progress</code>, <code>Done</code></li> <li>Delay calculation correct for past-due items with <code>statusCategory != Done</code></li> <li><code>needsReview</code> flag set for items with missing critical data</li> <li>Null/undefined fields replaced with safe defaults (empty string, 0, etc.)</li> <li>Unit tests verify all normalization rules and edge cases</li> </ul> </li> <li> <p>Dependencies: TASK-B002, TASK-B003</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Create normalization utility functions</li> <li>Implement status-to-category mapper</li> <li>Build delay calculation logic</li> <li>Add validation and <code>needsReview</code> flagging</li> <li>Handle null/undefined field defaults</li> <li>Write comprehensive unit tests</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#testing-documentation","title":"\u2728 Testing &amp; Documentation","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-d001-integration-testing-with-test-jira-project","title":"TASK-D001: Integration testing with test Jira project","text":"<ul> <li>Summary: JIRA-CLIENT - Integration Tests with Real Jira API</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 5</li> <li>Priority: Medium</li> <li>Labels: testing, integration, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Create integration test suite that calls actual Jira Cloud API using test credentials and validates end-to-end data fetching and normalization.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Setup test Jira Cloud project with synthetic data</li> <li>Create sample Epics, Stories, Bugs, Tasks with known relationships</li> <li>Test all fetch methods: versions, epics, stories, bugs, tasks</li> <li>Verify pagination by creating 100+ test issues</li> <li>Test rate-limit handling (if possible within limits)</li> <li>Validate DTO structure and data accuracy</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>Integration tests run against test Jira project</li> <li>Test credentials loaded from separate <code>.env.test</code> file</li> <li>All fetch methods successfully return expected DTOs</li> <li>Pagination tested with multi-page results</li> <li>DTO normalization verified with real Jira response shapes</li> <li>Tests pass in CI/CD with mocked responses (real tests optional in CI)</li> </ul> </li> <li> <p>Dependencies: TASK-C001, TASK-C002, TASK-C003</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Setup test Jira Cloud project and credentials</li> <li>Create synthetic test data in Jira</li> <li>Write integration tests for each fetch method</li> <li>Test pagination with 100+ issues</li> <li>Add CI/CD configuration with mocked responses</li> <li>Document test data setup process</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-d002-api-documentation-and-usage-examples","title":"TASK-D002: API documentation and usage examples","text":"<ul> <li>Summary: JIRA-CLIENT - Documentation &amp; Developer Guide</li> <li>Issue Type: Story</li> <li>Epic Link: JIRA-CLIENT Epic</li> <li>Story Points: 2</li> <li>Priority: Low</li> <li>Labels: documentation, jira-client</li> <li> <p>Components: JIRA-CLIENT</p> </li> <li> <p>Description:</p> <p>Write comprehensive API documentation, usage examples, configuration guide, and troubleshooting tips for JIRA-CLIENT module.</p> </li> <li> <p>Technical Requirements:</p> <ul> <li>Document all public methods with JSDoc comments</li> <li>Create <code>README.md</code> with setup instructions</li> <li>Provide code examples for common use cases</li> <li>Document environment variable configuration</li> <li>Add troubleshooting section for common errors</li> <li>Include DTO interface documentation</li> </ul> </li> <li> <p>Acceptance Criteria:</p> <ul> <li>All public methods have JSDoc comments with parameter types</li> <li><code>README.md</code> includes: setup, configuration, usage examples, troubleshooting</li> <li>Code examples cover: authentication, fetching releases, epics, stories</li> <li>Environment variables documented with required/optional indicators</li> <li>Troubleshooting guide covers: auth failures, rate limits, JQL errors</li> <li>API reference generated from JSDoc comments</li> </ul> </li> <li> <p>Dependencies: TASK-D001</p> </li> <li> <p>Jira Sub-tasks:</p> <ul> <li>Add JSDoc comments to all public methods</li> <li>Write <code>README.md</code> with setup guide</li> <li>Create usage example code snippets</li> <li>Document environment variables</li> <li>Write troubleshooting guide</li> <li>Generate API reference documentation</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#4-task-dependencies-sequencing","title":"4. Task Dependencies &amp; Sequencing","text":"<pre><code>graph TD\n    A001[A001: Setup Module] --&gt; A002[A002: Authentication]\n    A002 --&gt; B001[B001: Fetch Releases]\n    A002 --&gt; B002[B002: Fetch Epics/Stories]\n    A002 --&gt; C002[C002: Rate Limit &amp; Retry]\n    B001 --&gt; B002\n    B002 --&gt; B003[B003: Fetch Bugs/Tasks]\n    B002 --&gt; C001[C001: Pagination]\n    B003 --&gt; C003[C003: Normalization]\n    C001 --&gt; C003\n    C001 --&gt; D001[D001: Integration Tests]\n    C002 --&gt; D001\n    C003 --&gt; D001\n    D001 --&gt; D002[D002: Documentation]\n\n    classDef foundation fill:#e1f5fe,stroke:#01579b\n    classDef core fill:#f3e5f5,stroke:#4a148c\n    classDef integration fill:#e8f5e8,stroke:#1b5e20\n    classDef polish fill:#fff3e0,stroke:#e65100\n\n    class A001,A002 foundation\n    class B001,B002,B003 core\n    class C001,C002,C003 integration\n    class D001,D002 polish</code></pre>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#5-parallel-development-opportunities","title":"5. Parallel Development Opportunities","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#what-can-be-built-simultaneously","title":"What Can Be Built Simultaneously:","text":"<ul> <li>After A002: B001 and C002 can start in parallel</li> <li>After B002: B003 and C001 can start in parallel</li> <li>After C001, C002, C003: All prerequisites for D001 integration tests</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#critical-path","title":"Critical Path:","text":"<p>A001 \u2192 A002 \u2192 B002 \u2192 C003 \u2192 D001 \u2192 D002</p>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#6-risk-mitigation-tasks","title":"6. Risk Mitigation Tasks","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#technical-risks","title":"Technical Risks:","text":"<ul> <li>Risk JIRA-R1 (Rate Limits): Mitigated in TASK-C002 with backoff and retry</li> <li>Risk JIRA-R2 (Custom Fields): Epic Link field ID configurable via env in TASK-B002</li> <li>Risk JIRA-R3 (Data Quality): <code>needsReview</code> flags in TASK-C003 normalization</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#7-definition-of-done","title":"7. Definition of Done","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#task-completion-criteria","title":"Task Completion Criteria:","text":"<ul> <li>\u2705 All acceptance criteria met</li> <li>\u2705 Unit tests written and passing (&gt;80% coverage)</li> <li>\u2705 Code review completed</li> <li>\u2705 Integration tests passing (where applicable)</li> <li>\u2705 JSDoc documentation added</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#component-completion-criteria","title":"Component Completion Criteria:","text":"<ul> <li>\u2705 All tasks completed per definition of done</li> <li>\u2705 Technical specification requirements met</li> <li>\u2705 Integration with DATA-LAYER verified</li> <li>\u2705 Authentication and rate-limiting robust</li> <li>\u2705 Ready for ingestion pipeline integration</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#8-estimation-summary","title":"8. Estimation Summary","text":"Category Task Count Total Effort Duration (days) Foundation &amp; Setup 2 5 points 2-3 days Core Implementation 3 11 points 5-6 days Integration &amp; Resilience 3 11 points 5-6 days Testing &amp; Documentation 2 7 points 3-4 days TOTAL 10 34 points 15-19 days"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#9-traceability-matrix","title":"9. Traceability Matrix","text":"Task ID Technical Spec Section Functional Requirements Business Value A001 Section 5.1 Setup/Infrastructure Development efficiency A002 Section 8.1 FR-JIRA-CLIENT-001 Secure API access B001 Section 3.1 FR-JIRA-CLIENT-002 Release data fetching B002 Section 3.1, 4.1 FR-JIRA-CLIENT-003 Epic-Story hierarchy B003 Section 3.1 FR-JIRA-CLIENT-004 Quality signals data C001 Section 3.2 FR-JIRA-CLIENT-005 Large dataset handling C002 Section 6.2 FR-JIRA-CLIENT-005 API resilience C003 Section 4.1, 4.3 FR-JIRA-CLIENT-006 Data quality D001 Section 10.2 Testing Strategy Quality assurance D002 Section 11.1 Documentation Developer experience"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#10-implementation-notes","title":"10. Implementation Notes","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#development-best-practices","title":"Development Best Practices:","text":"<ul> <li>Use strongly-typed DTOs with TypeScript interfaces</li> <li>Implement request/response interceptors for cross-cutting concerns</li> <li>Use structured logging with correlation IDs for debugging</li> <li>Keep Jira-specific logic isolated from business logic</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#quality-gates","title":"Quality Gates:","text":"<ul> <li>Unit test coverage minimum 80%</li> <li>Integration tests pass with test Jira project</li> <li>No credentials logged or exposed in errors</li> <li>Rate-limit handling tested with retry scenarios</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-development-tasks/#communication-plan","title":"Communication Plan:","text":"<ul> <li>Daily standup updates on API integration progress</li> <li>Demo working Jira connectivity after TASK-A002</li> <li>Escalate Jira Cloud API issues to Atlassian support if needed</li> <li>Document any custom field discoveries for team reference</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/","title":"PRD - Phase 1","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#1-module-overview","title":"1. Module Overview","text":"<ul> <li>Purpose: Provide a secure, resilient Jira API client to fetch Epics, Stories, Bugs, and Tasks with correct release membership mapping.</li> <li>Business Value: Ensures trustworthy data ingestion for HALDI, enabling accurate hierarchy, progress, and signals downstream.</li> <li>User Value: Indirect\u2014users receive reliable, current release data powering the UI and reports.</li> <li>Module Type: Core (Foundation)</li> <li>Phase 1 Scope: Authentication (API token/OAuth), pagination, rate-limit backoff, normalized payloads, fixVersion/labels mapping, error handling.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#2-scope-boundaries","title":"2. Scope &amp; Boundaries","text":"<ul> <li>In Scope:<ul> <li>Secure auth configuration (API token or OAuth) and secret management.</li> <li>Fetch endpoints: search (JQL), issue detail, versions, changelog, priority taxonomy.</li> <li>Pagination (<code>maxResults</code>, <code>startAt</code>) and accumulation for large datasets.</li> <li>Rate-limit handling with exponential backoff and retries for transient errors.</li> <li>Normalization/mapping of payloads to HALDI domain (Release, Epic, Story, Bug, Task).</li> <li>Release membership detection via <code>fixVersion</code> and fallback labels.</li> <li>Structured error surfaces with actionable messages.</li> </ul> </li> <li>Out of Scope:<ul> <li>Database persistence or scheduler jobs (DATA-LAYER).</li> <li>Public app APIs for UI (APP-APIS).</li> <li>Complex forecasting or calculations (delays/timeline shift beyond basic fields).</li> </ul> </li> <li>Dependencies:<ul> <li>Jira Cloud API v3 availability and credentials.</li> <li>Network connectivity and adherence to Jira rate limits.</li> </ul> </li> <li>Dependents:<ul> <li>DATA-LAYER (ingestion pipeline uses this client).</li> <li>APP-APIS (reads persisted outputs shaped by this client\u2019s normalization).</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#3-user-personas-contexts","title":"3. User Personas &amp; Contexts","text":"<ul> <li>Persona: Backend Developer / Platform Engineer</li> <li>Goals: Fetch clean, complete data from Jira reliably to power HALDI.</li> <li>Context: Early MVP; establishing robust patterns for later ingestion and APIs.</li> <li>Pain Points: Rate limits, inconsistent fields, pagination complexity, error handling.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#4-user-stories","title":"4. User Stories","text":"<ul> <li>US-JIRA-CLIENT-001: As an engineer, I want authenticated Jira access so that I can fetch issues securely.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given configured credentials, when I call Jira API, then auth succeeds and is audited.</li> <li>Given invalid credentials, when I call, then I get clear errors without exposing secrets.</li> </ul> </li> <li>US-JIRA-CLIENT-002: As an engineer, I want pagination handling so that I can fetch complete datasets for releases.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given large result sets, when fetching, then results accumulate until total is reached.</li> <li>Given rate limits mid-fetch, when retrying, then backoff applies without data loss.</li> </ul> </li> <li>US-JIRA-CLIENT-003: As an engineer, I want normalized payloads so that downstream modules can rely on consistent fields.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given Jira responses, when normalized, then entities map to Release/Epic/Story/Bug/Task shapes with keys and associations.</li> </ul> </li> <li>US-JIRA-CLIENT-004: As an engineer, I want release membership mapping so that items are correctly tied to selected releases.</li> <li>Priority: Medium</li> <li>Acceptance Criteria:<ul> <li>Given items with <code>fixVersion</code> or labels, when mapped, then membership is correctly flagged; missing fields handled via fallbacks.</li> </ul> </li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#5-functional-requirements","title":"5. Functional Requirements","text":"<ul> <li>FR-JIRA-CLIENT-001: Authenticate with Jira API using configured method (API token or OAuth) and store secrets securely.</li> <li>Related Project FR: FR-001.</li> <li>Module Context: Foundation for all data access.</li> <li>FR-JIRA-CLIENT-002: Implement JQL search to retrieve Epics/Stories/Bugs/Tasks by release membership.</li> <li>Related Project FR: FR-002, FR-003.</li> <li>Module Context: Enables hierarchy construction.</li> <li>FR-JIRA-CLIENT-003: Support pagination and rate-limit backoff with bounded retries.</li> <li>Related Project FR: Non-functional performance/reliability.</li> <li>Module Context: Ensures complete and stable fetches.</li> <li>FR-JIRA-CLIENT-004: Normalize responses to HALDI entity shapes with essential fields and relationships.</li> <li>Related Project FR: Data Models &amp; Entities (placeholder now, define via samples).</li> <li>Module Context: Downstream compatibility.</li> <li>FR-JIRA-CLIENT-005: Map release membership via <code>fixVersion</code> and fallback to labels when absent.</li> <li>Related Project FR: Rule 5.</li> <li>Module Context: Accurate scoping of items.</li> <li>FR-JIRA-CLIENT-006: Provide structured error handling and descriptive messages for API/network failures.</li> <li>Related Project FR: FR-015.</li> <li>Module Context: Developer diagnostics and resilience.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#6-business-rules-logic","title":"6. Business Rules &amp; Logic","text":"<ul> <li>BR-JIRA-CLIENT-001: Respect Jira rate limits\u2014throttle requests and backoff exponentially.</li> <li>Example: Retry up to 3 times with jittered delays on 429/5xx.</li> <li>Edge Cases: Hard-stop on persistent 4xx credentials errors.</li> <li>BR-JIRA-CLIENT-002: Idempotent fetch behavior\u2014avoid duplicate records within a single fetch cycle.</li> <li>Example: Track <code>startAt</code> and item keys to prevent duplication.</li> <li>Edge Cases: Resume safely after partial failures.</li> <li>BR-JIRA-CLIENT-003: Normalize custom fields (e.g., Epic Link) via project-specific configuration.</li> <li>Example: Map Epic Link custom field ID to standard association.</li> <li>Edge Cases: If unknown, flag for manual mapping.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#7-user-interface-requirements","title":"7. User Interface Requirements","text":"<ul> <li>None (module is headless). Optional: developer CLI or logs to inspect responses.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#8-data-requirements","title":"8. Data Requirements","text":"<ul> <li>Input Data: Jira issues, versions, priorities via REST API v3.</li> <li>Output Data: Normalized entities (Release/Epic/Story/Bug/Task) passed to ingestion layer.</li> <li>Stored Data: None in this module; persistence handled by DATA-LAYER.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#9-integration-specifications","title":"9. Integration Specifications","text":"<ul> <li>APIs/Interfaces: Jira REST v3: <code>/search</code>, <code>/issue/{id}</code>, <code>/project/{id}/versions</code>, <code>/issue/{id}/changelog</code>, <code>/priority</code>.</li> <li>Events: None.</li> <li>Data Flow: External \u2192 Client \u2192 Normalized outputs (to ingestion).</li> <li>Error Handling: Retry/backoff, structured errors, audit logs for calls (timestamps, counts, statuses).</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#10-performance-quality-requirements","title":"10. Performance &amp; Quality Requirements","text":"<ul> <li>Performance: Typical release queries return in \u2264 10 seconds; pagination completes within acceptable windows.</li> <li>Reliability: Retries on transient errors; clear failures on auth/permission issues.</li> <li>Security: Secrets stored securely; responses sanitized in logs.</li> <li>Usability: Developer diagnostics sufficient to troubleshoot (counts, timings, error details).</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#11-success-metrics","title":"11. Success Metrics","text":"<ul> <li>Business Metrics: \u226595% correct release mapping; \u226590% hierarchical completeness downstream.</li> <li>User Metrics: Time-to-first data for MVP \u2264 1 hour setup.</li> <li>Technical Metrics: \u2264 1% error rate on fetches; \u2264 3 retries per batch; audited logs per run.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#12-edge-cases-error-scenarios","title":"12. Edge Cases &amp; Error Scenarios","text":"<ul> <li>Error Case 1: Invalid credentials or expired token.</li> <li>User Experience: Clear error; setup guidance.</li> <li>System Behavior: Abort without retries; redact secrets.</li> <li>Edge Case 1: Inconsistent status history or missing fields.</li> <li>Business Logic: Flag items for manual review; continue fetch.</li> <li>User Impact: Downstream modules handle markers (\"Needs Review\").</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Enhancement 1: Add caching to reduce rate-limit pressure.</li> <li>Enhancement 2: Support additional platforms beyond Jira via adapters.</li> <li>Enhancement 3: CLI for dry-run sampling and schema inference.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#14-acceptance-criteria-summary","title":"14. Acceptance Criteria Summary","text":"<ul> <li> Auth configured and verified; secrets stored securely.</li> <li> JQL fetches retrieve Epics/Stories/Bugs/Tasks with pagination.</li> <li> Rate-limit backoff and retries implemented with audit logs.</li> <li> Normalized outputs for entities and release membership mapping.</li> <li> Structured error handling with descriptive messages.</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-product-spec/#15-open-questions","title":"15. Open Questions","text":"<ul> <li>Question 1: Which auth method (API token vs OAuth) will be standard for environments?</li> <li>Question 2: What is the custom field ID for Epic Link in target Jira projects?</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/","title":"TRD - Phase 1","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#1-component-overview","title":"1. Component Overview","text":"<ul> <li>Purpose: Securely consume Jira Cloud APIs to fetch Epics, Stories, Bugs, Tasks, and Releases, normalizing payloads for ingestion into the DATA-LAYER.</li> <li>Scope: Implement authenticated client, pagination and rate-limit handling, core endpoints, normalized output contracts, and scheduler integration hooks.</li> <li>Phase 1 Scope: Read-only API consumption with retries/backoff, idempotent batch fetches, and response normalization; write to DATA-LAYER via ingestion jobs (separate module).</li> <li>Dependencies: Jira Cloud API v3, secure credentials (API token/OAuth), network connectivity.</li> <li>Dependents: DATA-LAYER (ingestion pipeline), APP-APIS (serves persisted data), REPORTING (later).</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#2-functional-requirements","title":"2. Functional Requirements","text":"<ul> <li>FR-JIRA-CLIENT-001: Authenticate with Jira (API token or OAuth) and store secrets securely.</li> <li>FR-JIRA-CLIENT-002: Fetch releases via versions metadata and map fixVersion/labels.</li> <li>FR-JIRA-CLIENT-003: Fetch Epics and linked Stories for a target release (via JQL/search).</li> <li>FR-JIRA-CLIENT-004: Fetch Bugs by priority and Tasks by status linked to Stories.</li> <li>FR-JIRA-CLIENT-005: Support pagination (<code>startAt</code>, <code>maxResults</code>) and rate-limit backoff.</li> <li>FR-JIRA-CLIENT-006: Provide normalized response contracts to DATA-LAYER ingestion.</li> <li>FR-JIRA-CLIENT-007: Expose scheduler hooks for periodic data pulls (ingestion triggers).</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#3-component-interface","title":"3. Component Interface","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#31-client-api","title":"3.1 Client API","text":"<ul> <li><code>getVersions(projectId)</code> \u2192 Versions (releases)</li> <li><code>searchIssues(jql, options)</code> \u2192 Paginated Issues</li> <li><code>getIssue(issueIdOrKey)</code> \u2192 Issue detail</li> <li><code>getIssueChangelog(issueIdOrKey)</code> \u2192 Status history (for delay heuristics)</li> <li><code>getPriorities()</code> \u2192 Bug priority taxonomy</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#32-inputoutput-contracts","title":"3.2 Input/Output Contracts","text":"<ul> <li>Inputs: Jira base URL, credentials, project/release identifiers, JQL filters</li> <li>Outputs: Normalized entities: <code>Release</code>, <code>Epic</code>, <code>Story</code>, <code>Bug</code>, <code>Task</code> with minimal field sets (<code>key</code>, <code>summary</code>, <code>statusCategory</code>, <code>issuetype</code>, <code>fixVersions</code>, <code>labels</code>, <code>assignee</code>, <code>duedate</code>, <code>priority</code>, links)</li> <li>Data Formats: JSON; strongly-typed mappers to internal DTOs</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#33-error-handling","title":"3.3 Error Handling","text":"<ul> <li>Error Types: Auth failure, rate limited, network error, API error, invalid JQL</li> <li>Error Responses: Standardized error object <code>{ code, message, details }</code>; retries with exponential backoff on transient errors</li> <li>Recovery Strategies: Partial batch completion with audit logs; continue pagination; skip corrupt items with <code>needsReview</code></li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#4-data-model","title":"4. Data Model","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#41-normalization-mappers","title":"4.1 Normalization Mappers","text":"<ul> <li>Map Jira <code>status</code> \u2192 <code>statusCategory</code> (To Do/In Progress/Done)</li> <li>Derive <code>release membership</code> from <code>fixVersions</code> or <code>labels</code></li> <li>Resolve <code>Epic \u2194 Story</code> via Epic Link custom field and issue links</li> <li>Derive <code>delayDays</code> from <code>duedate</code> vs current date and <code>statusCategory</code></li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#42-data-flow","title":"4.2 Data Flow","text":"<pre><code>flowchart TD\n    A[JIRA Cloud API] --&gt; B[JIRA-CLIENT]\n    B --&gt; C[Normalized DTOs]\n    C --&gt; D[Ingestion Jobs]\n    D --&gt; E[DATA-LAYER DB]</code></pre>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#43-data-validation","title":"4.3 Data Validation","text":"<ul> <li>Input Validation: Validate project/release IDs; JQL sanitization</li> <li>Business Rules: Ensure consistent DTO shapes; mark unknowns with <code>needsReview</code></li> <li>Data Integrity: Idempotent runs using <code>updated</code> timestamp and changelog</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#5-technology-stack","title":"5. Technology Stack","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#51-core-technologies","title":"5.1 Core Technologies","text":"<ul> <li>Programming Language: TypeScript</li> <li>Framework: Node/Nest-friendly client package (usable by ingestion)</li> <li>HTTP: <code>fetch</code>/<code>axios</code> with interceptors for auth and backoff</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#52-technology-rationale","title":"5.2 Technology Rationale","text":"<ul> <li>Why These Choices: Interoperable with NestJS app and Node jobs; mature HTTP tooling</li> <li>Alternatives Considered: Direct Atlassian SDKs; heavier integration than needed</li> <li>Trade-offs: Custom client logic needed for backoff and normalization</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#6-integration-design","title":"6. Integration Design","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#61-dependency-integration","title":"6.1 Dependency Integration","text":"<ul> <li>DATA-LAYER: Emit normalized DTOs to ingestion pipeline</li> <li>Communication Method: In-memory handoff or message queue (Phase 1: direct call)</li> <li>Data Exchange: Typed DTO arrays with pagination cursors</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#62-service-integration","title":"6.2 Service Integration","text":"<ul> <li>External APIs: Jira Cloud REST API v3</li> <li>Authentication: API token via Basic Auth or OAuth; secrets via env/secret store</li> <li>Rate Limiting: Detect 429; exponential backoff with jitter; max 3 retries</li> <li>Fallback Strategies: Reduce <code>maxResults</code>; pause/resume batches</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#71-requirements","title":"7.1 Requirements","text":"<ul> <li>Response Time: Single page fetch \u2264 2s typical</li> <li>Throughput: Batch ingestion within 10 minutes for typical releases</li> <li>Scalability: Paginated fetch with configurable page size</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#72-strategies","title":"7.2 Strategies","text":"<ul> <li>Batching: Page through <code>maxResults</code> with cursors; parallel-safe but single-threaded per project</li> <li>Filtering: Use JQL to constrain payloads to target release</li> <li>Resource Management: Avoid excessive concurrency; respect quotas</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#8-security-design","title":"8. Security Design","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#81-requirements","title":"8.1 Requirements","text":"<ul> <li>Authentication: API token/OAuth mandatory</li> <li>Authorization: Scoped to project(s) needed</li> <li>Data Protection: Do not persist credentials; redact sensitive fields</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#82-implementation","title":"8.2 Implementation","text":"<ul> <li>Encryption: TLS; secure env vars; avoid logging credentials</li> <li>Input Sanitization: JQL construction avoids injection</li> <li>Audit Logging: Log run ID, start/end times, counts, failures</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#9-monitoring-observability","title":"9. Monitoring &amp; Observability","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#91-logging","title":"9.1 Logging","text":"<ul> <li>Log Levels: Info for batch steps; Warn/Error for retries/failures</li> <li>Log Format: Structured logs with correlation IDs/run IDs</li> <li>Sensitive Data: Redact tokens and PII</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#92-metrics","title":"9.2 Metrics","text":"<ul> <li>Performance Metrics: Pages fetched, items per second, retry counts</li> <li>Business Metrics: Releases/Epics/Stories/Bugs/Tasks counts per run</li> <li>Alerting: Optional threshold alerts on failure rates</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#10-testing-strategy","title":"10. Testing Strategy","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#101-unit-testing","title":"10.1 Unit Testing","text":"<ul> <li>Coverage: Auth interceptor, backoff logic, mappers</li> <li>Key Test Cases: Pagination, rate-limit handling, DTO normalization</li> <li>Mock Dependencies: Mock HTTP responses for Jira endpoints</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#102-integration-testing","title":"10.2 Integration Testing","text":"<ul> <li>Points: End-to-end sample fetches against a test Jira project</li> <li>Test Data: Synthetic issues with known fields and relationships</li> <li>Environment: Secrets injected via env; limited rate-limit tests</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#11-deployment-considerations","title":"11. Deployment Considerations","text":""},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#111-requirements","title":"11.1 Requirements","text":"<ul> <li>Infrastructure: Node runtime for jobs/client</li> <li>Configuration: Jira base URL, credentials, project IDs, page size</li> <li>Secrets: Store in env/secret manager; rotate regularly</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#112-strategy","title":"11.2 Strategy","text":"<ul> <li>Build: Package client library; include type defs</li> <li>Deploy: Ship with ingestion service; versioned releases</li> <li>Rollback: Previous client version</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#12-risk-mitigation","title":"12. Risk Mitigation","text":"<ul> <li>Risk R1 (Rate Limits): Backoff + pagination; chunked batches</li> <li>Risk R2 (Custom Fields): Configurable Epic Link field ID mapping</li> <li>Risk R3 (Data Quality): <code>needsReview</code> flags; empty-state guidance</li> </ul>"},{"location":"implementation/JIRA-CLIENT/phase-1-technical-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Extensibility: Support Agile API for sprints; webhooks for change events</li> <li>Migration Path: Move to OAuth with refresh; per-project concurrency tuning</li> <li>Deprecation Strategy: Version DTOs and client methods</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/","title":"PRD - Phase 1","text":""},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#1-module-overview","title":"1. Module Overview","text":"<ul> <li>Purpose: Generate and scaffold HALDI\u2019s base UI from Figma designs, providing core screens and navigation without live data binding.</li> <li>Business Value: Accelerates MVP delivery by establishing a consistent, reusable UI shell aligned to design, enabling rapid integration of data and features.</li> <li>User Value: Gives PM/DM users a navigable interface to select releases and preview hierarchy/KPI layouts, setting expectations for forthcoming functionality.</li> <li>Module Type: Core (Foundation)</li> <li>Phase 1 Scope: Figma-to-code generation, routing and page scaffolds, static UI for Release Selector, Hierarchy View, KPI Summary; no backend integration.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#2-scope-boundaries","title":"2. Scope &amp; Boundaries","text":"<ul> <li>In Scope:<ul> <li>Figma-based component/page generation for <code>apps/ui-hk-gamar</code>.</li> <li>App routing and navigation tabs consistent with Material theme.</li> <li>Static layouts for Release Selector, Epic \u2192 Story Hierarchy, KPI Summary, and placeholder panes for Bugs/Tasks/Delays.</li> <li>Responsive styles and accessibility baseline (keyboard nav, semantic markup).</li> <li>Theming setup aligned with mkdocs/material style (light/dark toggle awareness).</li> </ul> </li> <li>Out of Scope:<ul> <li>Live data fetching, API calls, or state management.</li> <li>Report export (PDF/Markdown/Link).</li> <li>Delay calculations or dynamic KPI computation.</li> <li>Authentication/authorization.</li> </ul> </li> <li>Dependencies:<ul> <li>Figma design artifacts and tokens for codegen.</li> <li>Repository structure <code>apps/ui-hk-gamar</code> ready to receive generated components.</li> </ul> </li> <li>Dependents:<ul> <li>USER-INTERFACE (Phase 2) binds these UI shells to APP-APIS.</li> <li>REPORTING leverages established component structure for export views.</li> </ul> </li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#3-user-personas-contexts","title":"3. User Personas &amp; Contexts","text":"<ul> <li>Persona: Project Manager / Delivery Manager</li> <li>Goals: Navigate releases; view hierarchical layout and KPIs framework to understand intended capabilities.</li> <li>Context: Early MVP; validating UI flows and layout before data integration.</li> <li>Pain Points: Fragmented views and inconsistency; need predictable UI shell that will host real signals later.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#4-user-stories","title":"4. User Stories","text":"<ul> <li>US-UI-CODEGEN-001: As a PM, I want a Release Selector screen so that I can choose a target release to view in subsequent pages.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given the app loads, when I open Release Selector, then I see a list UI placeholder with filter/search controls.</li> <li>Given I select a placeholder release, when I proceed, then routing moves me to Hierarchy View with the selected release context displayed statically.</li> </ul> </li> <li>US-UI-CODEGEN-002: As a PM, I want a hierarchical Epic \u2192 Story layout so that I understand the structure of the release view.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given Hierarchy View, when I expand an Epic, then I see nested Story items (static).</li> <li>Given spanning/multi-linked/orphan sections, when I navigate, then I see labeled placeholders indicating edge-case handling in later phases.</li> </ul> </li> <li>US-UI-CODEGEN-003: As a PM, I want KPI Summary tiles so that I can see where progress/quality/workload metrics will appear.</li> <li>Priority: Medium</li> <li>Acceptance Criteria:<ul> <li>Given KPI Summary, when I view the top section, then I see tiles for completion, epics completed, stories on track, open bugs, open tasks, delayed items (static counts).</li> </ul> </li> <li>US-UI-CODEGEN-004: As a PM, I want tabs/sections for Bugs, Tasks, and Delays so that I can preview the UI for signals.</li> <li>Priority: Medium</li> <li>Acceptance Criteria:<ul> <li>Given signals tabs, when I switch tabs, then I see static lists/placeholders with priority/status legends.</li> </ul> </li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#5-functional-requirements","title":"5. Functional Requirements","text":"<ul> <li>FR-UI-CODEGEN-001: Generate base UI components and pages from Figma designs into <code>apps/ui-hk-gamar</code>.</li> <li>Related Project FR: Supports overall MVP UI as per roadmap foundation.</li> <li>Module Context: Establishes the screens required by core use cases without data.</li> <li>FR-UI-CODEGEN-002: Implement routing for Release Selector \u2192 Hierarchy \u2192 KPI Summary with navigation tabs.</li> <li>Related Project FR: Aligns to hierarchical view and signals structure.</li> <li>Module Context: Ensures coherent navigation paths for later data binding.</li> <li>FR-UI-CODEGEN-003: Provide accessible, responsive layouts using the project\u2019s Material theme.</li> <li>Related Project FR: Usability non-functional requirements.</li> <li>Module Context: Baseline UX consistency across screens.</li> <li>FR-UI-CODEGEN-004: Include placeholders for edge cases (spanning epics, multi-linked stories, orphaned items).</li> <li>Related Project FR: Edge case handling guidance (to be made dynamic later).</li> <li>Module Context: Visual cues for future logic.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#6-business-rules-logic","title":"6. Business Rules &amp; Logic","text":"<ul> <li>BR-UI-CODEGEN-001: UI must mirror Figma structure and naming to reduce drift.</li> <li>Example: Component names and layout regions match Figma frames.</li> <li>Edge Cases: If designs are incomplete, scaffold generic components with clear TODO tags.</li> <li>BR-UI-CODEGEN-002: Navigation and page structure must anticipate data-binding without major refactor.</li> <li>Example: Containers accept future props/state without structural changes.</li> <li>Edge Cases: Provide adapter points for APP-APIS responses.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#7-user-interface-requirements","title":"7. User Interface Requirements","text":"<ul> <li>Screen/Page: Release Selector</li> <li>Purpose: Choose a release; search/filter controls (static).</li> <li>Key Elements: Header, list/grid placeholder, search bar, proceed CTA.</li> <li>User Flow: Selector \u2192 Hierarchy View.</li> <li>Validation Rules: None (no backend yet).</li> <li>Screen/Page: Hierarchy View</li> <li>Purpose: Present Epic \u2192 Story tree (static).</li> <li>Key Elements: Expandable Epic cards, nested Story items, edge-case badges (Partial/Multi-linked/Unlinked).</li> <li>User Flow: From Release Selector; tabs to signals and KPI Summary.</li> <li>Validation Rules: N/A.</li> <li>Screen/Page: KPI Summary &amp; Signals</li> <li>Purpose: Show KPI tiles and tabs for Bugs, Tasks, Delays (static).</li> <li>Key Elements: KPI tiles; tabbed panes; legends.</li> <li>User Flow: Navigable from Hierarchy View.</li> <li>Validation Rules: N/A.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#8-data-requirements","title":"8. Data Requirements","text":"<ul> <li>Input Data: None (static placeholders only).</li> <li>Output Data: None.</li> <li>Stored Data: None (no persistence in Phase 1).</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#9-integration-specifications","title":"9. Integration Specifications","text":"<ul> <li>APIs/Interfaces: None in Phase 1.</li> <li>Events: None.</li> <li>Data Flow: N/A.</li> <li>Error Handling: Client-side route guards and fallback UI for missing pages.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#10-performance-quality-requirements","title":"10. Performance &amp; Quality Requirements","text":"<ul> <li>Performance: Screens load in \u2264 2 seconds locally; routing instantaneous.</li> <li>Reliability: UI builds consistently across environments; no runtime errors in static navigation.</li> <li>Security: No secrets or auth in Phase 1.</li> <li>Usability: Basic accessibility: focus states, keyboard navigation, semantic landmarks.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#11-success-metrics","title":"11. Success Metrics","text":"<ul> <li>Business Metrics: Faster MVP velocity; reduced rework during data binding.</li> <li>User Metrics: PM/DM can navigate target screens without confusion (qualitative test).</li> <li>Technical Metrics: \u2264 1 structural change required when binding to APP-APIS; lighthouse accessibility baseline \u2265 80 (static).</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#12-edge-cases-error-scenarios","title":"12. Edge Cases &amp; Error Scenarios","text":"<ul> <li>Error Case 1: Missing or outdated Figma tokens.</li> <li>User Experience: Display a developer-facing setup note; proceed with generic scaffolds.</li> <li>System Behavior: Skip codegen; use placeholder components.</li> <li>Edge Case 1: Incomplete designs for a screen.</li> <li>Business Logic: Scaffold minimal viable layout with TODO markers.</li> <li>User Impact: Users still see the path and structure.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Enhancement 1: Bind Release Selector to <code>/releases</code> API; load real lists.</li> <li>Enhancement 2: Render dynamic hierarchy via <code>/release/:id/hierarchy</code> with progressive loading.</li> <li>Enhancement 3: Populate KPI tiles and signals from <code>/release/:id/signals</code>.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#14-acceptance-criteria-summary","title":"14. Acceptance Criteria Summary","text":"<ul> <li> Figma-driven components/pages generated in <code>apps/ui-hk-gamar</code>.</li> <li> Routing across Release Selector, Hierarchy View, KPI Summary works.</li> <li> Static placeholders for edge cases and signals present.</li> <li> Responsive and accessible baseline achieved.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-product-spec/#15-open-questions","title":"15. Open Questions","text":"<ul> <li>Question 1: Which specific Figma file/pages should be the source of truth for codegen?</li> <li>Question 2: Do we standardize component naming conventions to align with backend domain (Release/Epic/Story)?</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/","title":"TRD - Phase 1","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#1-component-overview","title":"1. Component Overview","text":"<ul> <li>Purpose: Generate base UI scaffolding from Figma designs and integrate into <code>apps/ui-hk-gamar</code>, providing screens, components, and routing skeletons for MVP.</li> <li>Scope: Figma-to-code generation for core views (dashboard, hierarchy, signals), alignment with design system, and integration hooks without backend bindings.</li> <li>Phase 1 Scope: Generate and import UI components, pages, and routes; ensure design parity; no data wiring.</li> <li>Dependencies: Figma designs, design system tokens/components; Nx/Vite setup.</li> <li>Dependents: USER-INTERFACE (binds data), APP-APIS (provides data contracts).</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#2-functional-requirements","title":"2. Functional Requirements","text":"<ul> <li>FR-UI-CODEGEN-001: Generate components for Dashboard, Hierarchy, Metrics, Delay Analysis, Bug/Task panels.</li> <li>FR-UI-CODEGEN-002: Provide routing and layout scaffolding (home, release view).</li> <li>FR-UI-CODEGEN-003: Ensure responsive design and accessibility basics from Figma specs.</li> <li>FR-UI-CODEGEN-004: Align styles with design tokens and utility classes.</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#3-component-interface","title":"3. Component Interface","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#31-public-ui-surfaces","title":"3.1 Public UI Surfaces","text":"<ul> <li>Pages: <code>Dashboard</code>, <code>ReleaseView</code></li> <li>Components: <code>MetricsOverview</code>, <code>HierarchyView</code>, <code>ReleaseProgress</code>, <code>BugTaskSummary</code>, <code>DelayAnalysis</code>, <code>DetailGrids</code></li> <li>Routing: <code>/</code>, <code>/release/:id</code> (add minimal client-side router scaffolding to <code>App.tsx</code>/<code>main.tsx</code> without data binding)</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#32-inputoutput-contracts","title":"3.2 Input/Output Contracts","text":"<ul> <li>Inputs: None (Phase 1, static placeholders)</li> <li>Outputs: Rendered UI elements matching Figma design</li> <li>Data Formats: Static props; data-binding deferred</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#33-error-handling","title":"3.3 Error Handling","text":"<ul> <li>Error Types: Missing assets or styles</li> <li>Error Responses: Visual fallbacks; <code>ImageWithFallback</code></li> <li>Recovery Strategies: Placeholder components and loading skeletons</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#4-data-model","title":"4. Data Model","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#41-ui-state","title":"4.1 UI State","text":"<ul> <li>Storage Type: Local component state for placeholders</li> <li>Data Schema: N/A Phase 1 (no API integration)</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#42-data-flow","title":"4.2 Data Flow","text":"<pre><code>flowchart TD\n    A[Figma Designs] --&gt; B[Code Generation]\n    B --&gt; C[UI Components]\n    C --&gt; D[Pages &amp; Routes]\n    D --&gt; E[USER-INTERFACE Binding (Phase 2)]</code></pre>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#43-validation","title":"4.3 Validation","text":"<ul> <li>Input Validation: N/A</li> <li>Business Rules: Maintain visual parity; use design tokens</li> <li>Integrity: Components structured for later data binding</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#5-technology-stack","title":"5. Technology Stack","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#51-core-technologies","title":"5.1 Core Technologies","text":"<ul> <li>Programming Language: TypeScript/React</li> <li>Framework: Vite + React (apps/ui-hk-gamar)</li> <li>Additional Libraries: Local UI components under <code>New Project Setup/src/components/ui/*</code></li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#52-technology-rationale","title":"5.2 Technology Rationale","text":"<ul> <li>Why These Choices: Matches existing setup and generated library</li> <li>Alternatives Considered: Next.js; not required for MVP</li> <li>Trade-offs: Client-side routing only; acceptable for MVP</li> <li>Frontend Context Alignment: Use <code>styles/globals.css</code> and <code>ui/*</code> components; apply CSS variables for chart/metric colors consistently</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#6-integration-design","title":"6. Integration Design","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#61-dependency-integration","title":"6.1 Dependency Integration","text":"<ul> <li>Design System: Use <code>ui/*</code> components and <code>styles/globals.css</code></li> <li>Communication Method: Component imports; CSS variables/tokens</li> <li>Data Exchange: Props for placeholders only</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#62-service-integration","title":"6.2 Service Integration","text":"<ul> <li>External Services: None in Phase 1</li> <li>Authentication: N/A</li> <li>Fallback Strategies: Skeleton loaders and image fallbacks</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#71-requirements","title":"7.1 Requirements","text":"<ul> <li>Response Time: UI loads within 3s on standard browsers</li> <li>Throughput: N/A</li> <li>Scalability: Component-level lazy loading optional</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#72-strategies","title":"7.2 Strategies","text":"<ul> <li>Code Splitting: Lazy load heavy components (optional)</li> <li>Asset Optimization: Use optimized images and CSS</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#8-security-design","title":"8. Security Design","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#81-requirements","title":"8.1 Requirements","text":"<ul> <li>Authentication: N/A</li> <li>Authorization: N/A</li> <li>Data Protection: No sensitive data</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#82-implementation","title":"8.2 Implementation","text":"<ul> <li>Sanitization: N/A</li> <li>Audit Logging: N/A</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#9-monitoring-observability","title":"9. Monitoring &amp; Observability","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#91-logging","title":"9.1 Logging","text":"<ul> <li>Client Logs: Minimal; dev-only</li> <li>Sensitive Data: None</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#92-metrics","title":"9.2 Metrics","text":"<ul> <li>Performance Metrics: Bundle size and load times (optional)</li> <li>Alerting: N/A</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#10-testing-strategy","title":"10. Testing Strategy","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#101-unit-testing","title":"10.1 Unit Testing","text":"<ul> <li>Coverage: Render tests for key components</li> <li>Key Test Cases: Component renders; responsive classes present</li> <li>Mock Dependencies: None</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#102-integration-testing","title":"10.2 Integration Testing","text":"<ul> <li>Points: Routing and layout</li> <li>Test Data: Static fixtures</li> <li>Environment: Vite dev server</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#11-deployment-considerations","title":"11. Deployment Considerations","text":""},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#111-requirements","title":"11.1 Requirements","text":"<ul> <li>Infrastructure: Static assets served via Vite/Nx</li> <li>Configuration: Base path and asset paths</li> <li>Secrets: None</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#112-strategy","title":"11.2 Strategy","text":"<ul> <li>Build: Vite build; Nx pipeline</li> <li>Deploy: Static hosting</li> <li>Rollback: Redeploy previous build</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#12-risk-mitigation","title":"12. Risk Mitigation","text":"<ul> <li>Risk R1 (Design Drift): Validate parity via visual review</li> <li>Risk R2 (Binding Complexity): Ensure component props anticipated for data binding</li> <li>Risk R3 (Accessibility): Use semantic markup and ARIA basics</li> </ul>"},{"location":"implementation/UI-CODEGEN/phase-1-technical-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Extensibility: Data binding with APP-APIS; state management</li> <li>Migration Path: Introduce SSR if needed</li> <li>Deprecation: Version UI components for evolution</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/","title":"PRD - Phase 1","text":""},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#1-module-overview","title":"1. Module Overview","text":"<ul> <li>Purpose: Bind the generated UI to APP-APIS to render real release data: selector, hierarchical view, KPI tiles, and signals.</li> <li>Business Value: Delivers visible user value by making progress, quality, and workload signals available in the UI.</li> <li>User Value: PM/DMs can select a release and see actual Epics/Stories, KPIs, bugs, and tasks with clear indicators.</li> <li>Module Type: Feature</li> <li>Phase 1 Scope: Data binding for Release Selector, Hierarchy View, KPI Summary, and signals tabs; progressive loading; edge-case indicators; basic empty/error states.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#2-scope-boundaries","title":"2. Scope &amp; Boundaries","text":"<ul> <li>In Scope:<ul> <li>Connect UI screens to APP-APIS endpoints (<code>/releases</code>, <code>/release/:id/hierarchy</code>, <code>/release/:id/signals</code>).</li> <li>Render hierarchy with Epics and nested Stories; show <code>partial</code>, <code>multiLinked</code>, <code>unlinked</code> indicators.</li> <li>Display KPI tiles and signal lists grouped by status/priority.</li> <li>Implement empty states, loading states, and error banners.</li> <li>Minimal client-side pagination or progressive loading for large data.</li> </ul> </li> <li>Out of Scope:<ul> <li>Authentication and role-based access.</li> <li>Report export (handled by REPORTING).</li> <li>Advanced filtering or complex analytics beyond Phase 1 KPIs.</li> </ul> </li> <li>Dependencies:<ul> <li>APP-APIS operational and returning consistent contracts.</li> </ul> </li> <li>Dependents:<ul> <li>REPORTING module benefits from verified UI rendering and data consistency.</li> </ul> </li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#3-user-personas-contexts","title":"3. User Personas &amp; Contexts","text":"<ul> <li>Persona: Project Manager / Delivery Manager</li> <li>Goals: Quickly select a release and view comprehensive hierarchy and signals.</li> <li>Context: MVP; validating data integrity and usability with real backend responses.</li> <li>Pain Points: Slow or inconsistent views; unclear error handling; missing edge-case transparency.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#4-user-stories","title":"4. User Stories","text":"<ul> <li>US-USER-INTERFACE-001: As a PM, I want to select a release so that I can view its hierarchy and signals.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given <code>/releases</code> is available, when I open Release Selector, then I see a paginated list with search; selecting one routes to hierarchy.</li> </ul> </li> <li>US-USER-INTERFACE-002: As a PM, I want to view Epic \u2192 Story hierarchy so that I understand scope and structure.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given <code>/release/:id/hierarchy</code>, when loaded, then Epics render with nested Stories; edge-case badges appear.</li> </ul> </li> <li>US-USER-INTERFACE-003: As a PM, I want KPI tiles so that I can see completion and signal summaries.</li> <li>Priority: High</li> <li>Acceptance Criteria:<ul> <li>Given <code>/release/:id/signals</code>, when loaded, then KPI tiles show completion, epics completed, stories on track, open bugs/tasks, delayed items.</li> </ul> </li> <li>US-USER-INTERFACE-004: As a PM, I want tabs for Bugs and Tasks so that I can inspect issues by priority/status.</li> <li>Priority: Medium</li> <li>Acceptance Criteria:<ul> <li>Given signals data, when I switch tabs, then grouped lists render with badges and counts.</li> </ul> </li> <li>US-USER-INTERFACE-005: As a PM, I want clear loading/empty/error states so that I can trust the UI during data fetches.</li> <li>Priority: Medium</li> <li>Acceptance Criteria:<ul> <li>Given slow responses or no data, when viewing, then I see spinners, empty messages, or error banners with retry.</li> </ul> </li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#5-functional-requirements","title":"5. Functional Requirements","text":"<ul> <li>FR-USER-INTERFACE-001: Bind Release Selector to <code>/releases</code> with pagination and search.</li> <li>Related Project FR: FR-016.</li> <li>Module Context: Entry point to data views.</li> <li>FR-USER-INTERFACE-002: Bind Hierarchy View to <code>/release/:id/hierarchy</code> and render nested structures.</li> <li>Related Project FR: FR-003\u2013FR-005.</li> <li>Module Context: Core hierarchical visualization.</li> <li>FR-USER-INTERFACE-003: Bind KPI tiles and signals tabs to <code>/release/:id/signals</code>.</li> <li>Related Project FR: FR-008\u2013FR-009, FR-016\u2013FR-017.</li> <li>Module Context: Summaries and detailed signals.</li> <li>FR-USER-INTERFACE-004: Implement loading, empty, and error states across views.</li> <li>Related Project FR: FR-014, FR-015.</li> <li>Module Context: Usability and resilience.</li> <li>FR-USER-INTERFACE-005: Support basic progressive loading for large hierarchies.</li> <li>Related Project FR: UC-002 Alternate flows.</li> <li>Module Context: Performance considerations.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#6-business-rules-logic","title":"6. Business Rules &amp; Logic","text":"<ul> <li>BR-USER-INTERFACE-001: Display consistent edge-case indicators for spanning/multi-linked/orphan items.</li> <li>Example: Badges and tooltips indicating context.</li> <li>Edge Cases: Unknown statuses labeled <code>Needs Review</code>.</li> <li>BR-USER-INTERFACE-002: Maintain UI responsiveness; avoid blocking renders during fetches.</li> <li>Example: Skeleton loaders; incremental rendering.</li> <li>Edge Cases: Defer secondary panes until primary hierarchy loads.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#7-user-interface-requirements","title":"7. User Interface Requirements","text":"<ul> <li>Screen/Page: Release Selector</li> <li>Purpose: Select a release via list/search.</li> <li>Key Elements: List/grid; search; pagination; select action.</li> <li>User Flow: Selector \u2192 Hierarchy View.</li> <li>Validation Rules: Input sanitization for search.</li> <li>Screen/Page: Hierarchy View</li> <li>Purpose: Render Epic \u2192 Story tree with indicators.</li> <li>Key Elements: Expandable Epics; nested Stories; badges; tabs.</li> <li>User Flow: Tabs to KPI Summary/Bugs/Tasks.</li> <li>Validation Rules: N/A.</li> <li>Screen/Page: KPI &amp; Signals</li> <li>Purpose: Show KPIs and grouped signals.</li> <li>Key Elements: KPI tiles; tabs; grouped lists.</li> <li>User Flow: Navigable from Hierarchy View.</li> <li>Validation Rules: N/A.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#8-data-requirements","title":"8. Data Requirements","text":"<ul> <li>Input Data: JSON from APP-APIS endpoints.</li> <li>Output Data: Rendered UI components; no outbound data.</li> <li>Stored Data: None; ephemeral client state only.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#9-integration-specifications","title":"9. Integration Specifications","text":"<ul> <li>APIs/Interfaces: <code>/releases</code>, <code>/release/:id/hierarchy</code>, <code>/release/:id/signals</code>.</li> <li>Events: None.</li> <li>Data Flow: API \u2192 UI components.</li> <li>Error Handling: Retry prompts; friendly messages; correlation ID surfaced if provided.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#10-performance-quality-requirements","title":"10. Performance &amp; Quality Requirements","text":"<ul> <li>Performance: Initial page renders in \u2264 3s; hierarchy incremental loads where needed.</li> <li>Reliability: Handles empty and partial data gracefully.</li> <li>Security: No secrets in client; sanitize displayed fields.</li> <li>Usability: Accessibility baseline\u2014focus management, ARIA labels for expandable items.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#11-success-metrics","title":"11. Success Metrics","text":"<ul> <li>Business Metrics: Users can view real data and confirm progress within MVP.</li> <li>User Metrics: Task completion (select release \u2192 view hierarchy) success \u2265 90% in tests.</li> <li>Technical Metrics: p95 render \u2264 3s for typical releases; error rate \u2264 1%.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#12-edge-cases-error-scenarios","title":"12. Edge Cases &amp; Error Scenarios","text":"<ul> <li>Error Case 1: API returns 404 for a release.</li> <li>User Experience: Not-found UI with link back to selector.</li> <li>System Behavior: No crashes; clear message.</li> <li>Edge Case 1: Very large hierarchies.</li> <li>Business Logic: Progressive loading of Epic sections.</li> <li>User Impact: Perceived responsiveness maintained.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Enhancement 1: Advanced filters (status, priority) for hierarchy and signals.</li> <li>Enhancement 2: Saved views and user preferences.</li> <li>Enhancement 3: Deep linking to specific Epics/Stories.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#14-acceptance-criteria-summary","title":"14. Acceptance Criteria Summary","text":"<ul> <li> Release Selector renders and navigates using <code>/releases</code>.</li> <li> Hierarchy View renders with edge-case indicators from <code>/release/:id/hierarchy</code>.</li> <li> KPI tiles and signals render from <code>/release/:id/signals</code>.</li> <li> Loading, empty, and error states implemented across screens.</li> <li> Progressive loading in place for large hierarchies.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-product-spec/#15-open-questions","title":"15. Open Questions","text":"<ul> <li>Question 1: Which UI filters are essential in Phase 1 (e.g., status, priority)?</li> <li>Question 2: Should we show delay heuristic tooltips in UI or defer to report only in Phase 1?</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/","title":"TRD - Phase 1","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#1-component-overview","title":"1. Component Overview","text":"<ul> <li>Purpose: Render the hierarchical release view, KPIs, bugs/tasks, and delay indicators by binding UI components to APP-APIS endpoints.</li> <li>Scope: Implement data fetching, state management, and UI binding for Dashboard and Release views using the generated components.</li> <li>Phase 1 Scope: Read-only binding to backend; progressive loading; empty/error states; minimal filters; no auth.</li> <li>Dependencies: APP-APIS (contracts), DATA-LAYER (populated data), UI-CODEGEN (components/pages).</li> <li>Dependents: REPORTING (optionally reads UI state for exports).</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#2-functional-requirements","title":"2. Functional Requirements","text":"<ul> <li>FR-UI-001: Release selector populated via <code>/api/releases</code> with pagination.</li> <li>FR-UI-002: Hierarchical view binds to <code>/api/release/:id/hierarchy</code> with edge-case indicators.</li> <li>FR-UI-003: KPIs and signals bind to <code>/api/release/:id/signals</code> (bugs/tasks grouped).</li> <li>FR-UI-004: Display delay indicators with days overdue and indicative timeline shift.</li> <li>FR-UI-005: Handle empty states and standardized errors gracefully.</li> <li>FR-UI-006: Render summary graphs for status breakdowns (bar/donut) using data from backend.</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#3-component-interface","title":"3. Component Interface","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#31-pages-components","title":"3.1 Pages &amp; Components","text":"<ul> <li>Pages: <code>Dashboard</code>, <code>ReleaseView</code></li> <li>Components: <code>MetricsOverview</code>, <code>HierarchyView</code>, <code>ReleaseProgress</code>, <code>BugTaskSummary</code>, <code>DelayAnalysis</code>, <code>DetailGrids</code>, charts</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#32-inputoutput-contracts","title":"3.2 Input/Output Contracts","text":"<ul> <li>Inputs: Backend responses per APP-APIS contracts; user interactions (select release). Compatibility layer maps existing mock endpoints to real routes.</li> <li>Outputs: Rendered UI; loading skeletons; error banners; tooltips for indicators</li> <li>Data Formats: JSON via fetch; typed client layer based on <code>New Project Setup/src/services/api.ts</code></li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#endpoint-mapping-client-service","title":"Endpoint Mapping (Client Service)","text":"<ul> <li><code>/api/releases/:id/metrics</code> \u2192 calls <code>/api/release/:id/signals</code> and maps to KPIs</li> <li><code>/api/releases/:id/epics</code> \u2192 calls <code>/api/release/:id/hierarchy</code> and maps to epics/stories</li> <li><code>/api/releases/:id/charts</code> \u2192 optional; derive chart data locally from signals/hierarchy for Phase 1</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#33-error-handling","title":"3.3 Error Handling","text":"<ul> <li>Error Types: Network/API errors; not-found; empty datasets</li> <li>Error Responses: UI banners/messages; retry options; empty-guidance tooltips</li> <li>Recovery Strategies: Progressive loading; partial renders; fallback graphs with zero values</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#4-data-model","title":"4. Data Model","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#41-ui-state","title":"4.1 UI State","text":"<ul> <li>Storage Type: Component-level state + lightweight client service</li> <li>Data Schema: Release list, selected release, hierarchy tree, signals/KPIs, chart datasets</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#42-data-flow","title":"4.2 Data Flow","text":"<pre><code>flowchart TD\n    A[APP-APIS] --&gt; B[Client Service]\n    B --&gt; C[UI State]\n    C --&gt; D[Dashboard Components]\n    C --&gt; E[Release View Components]</code></pre>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#43-data-validation","title":"4.3 Data Validation","text":"<ul> <li>Input Validation: Validate response shapes; default missing fields to safe values</li> <li>Business Rules: Show indicators for partial/multi-linked/unlinked stories</li> <li>Integrity: Keep UI consistent across refresh via deterministic rendering</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#5-technology-stack","title":"5. Technology Stack","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#51-core-technologies","title":"5.1 Core Technologies","text":"<ul> <li>Programming Language: TypeScript/React</li> <li>Framework: Vite + React (<code>apps/ui-hk-gamar</code>)</li> <li>Client Layer: <code>New Project Setup/src/services/api.ts</code> adapted to real endpoints</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#52-technology-rationale","title":"5.2 Technology Rationale","text":"<ul> <li>Why These Choices: Matches current setup and generated components</li> <li>Alternatives Considered: Global state (Redux) deferred for MVP</li> <li>Trade-offs: Local state may duplicate fetches; acceptable for MVP</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#6-integration-design","title":"6. Integration Design","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#61-dependency-integration","title":"6.1 Dependency Integration","text":"<ul> <li>APP-APIS: Bind to documented endpoints; map to component props</li> <li>Communication Method: Browser fetch with error handling and loaders</li> <li>Data Exchange: JSON responses mapped to UI models</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#62-service-integration","title":"6.2 Service Integration","text":"<ul> <li>External Services: None</li> <li>Authentication: Deferred</li> <li>Rate Limiting: N/A client-side (handle server 429 with user messaging)</li> <li>Fallback Strategies: Skeletons; degraded views; tooltips for unknowns</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#71-requirements","title":"7.1 Requirements","text":"<ul> <li>Response Time: Initial render \u2264 3s; progressive sections thereafter</li> <li>Throughput: N/A</li> <li>Scalability: Progressive loading; pagination for lists (releases)</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#72-strategies","title":"7.2 Strategies","text":"<ul> <li>Progressive UI: Load KPIs first, then hierarchy</li> <li>Chunked Rendering: Virtualize large lists (optional)</li> <li>Asset Optimization: Use CSS variables; reduce reflows</li> <li>Timeouts/Retry: Apply short timeouts (e.g., 5s) and a single retry for KPI fetch before rendering fallback</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#8-security-design","title":"8. Security Design","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#81-requirements","title":"8.1 Requirements","text":"<ul> <li>Authentication: Deferred</li> <li>Authorization: Deferred</li> <li>Data Protection: No sensitive data shown beyond essentials</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#82-implementation","title":"8.2 Implementation","text":"<ul> <li>Sanitization: Render-only; avoid HTML injection</li> <li>Audit Logging: N/A client-side</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#9-monitoring-observability","title":"9. Monitoring &amp; Observability","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#91-logging","title":"9.1 Logging","text":"<ul> <li>Client Logs: Minimal console logs in dev</li> <li>Sensitive Data: None logged</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#92-metrics","title":"9.2 Metrics","text":"<ul> <li>Performance Metrics: Optional web vitals; latency marks</li> <li>Alerting: N/A</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#10-testing-strategy","title":"10. Testing Strategy","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#101-unit-testing","title":"10.1 Unit Testing","text":"<ul> <li>Coverage: Components render with mock data; indicator visibility</li> <li>Key Test Cases: Empty/error states; KPI and chart rendering</li> <li>Mock Dependencies: Mock client service responses</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#102-integration-testing","title":"10.2 Integration Testing","text":"<ul> <li>Points: End-to-end fetch + render using dev backend</li> <li>Test Data: Sample releases/epics/stories/bugs/tasks</li> <li>Environment: Vite dev server + Nest backend</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#11-deployment-considerations","title":"11. Deployment Considerations","text":""},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#111-requirements","title":"11.1 Requirements","text":"<ul> <li>Infrastructure: Static hosting of Vite build</li> <li>Configuration: API base URL <code>/api</code>; env override</li> <li>Secrets: None</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#112-strategy","title":"11.2 Strategy","text":"<ul> <li>Build: Vite/Nx build; map base paths</li> <li>Deploy: Serve static files; backend proxy <code>/api</code></li> <li>Rollback: Redeploy previous build</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#12-risk-mitigation","title":"12. Risk Mitigation","text":"<ul> <li>Risk R1 (Contract Drift): Align models to APP-APIS TRD; adapt client</li> <li>Risk R2 (Large Hierarchies): Progressive load; virtualization (optional)</li> <li>Risk R3 (Data Quality): Show <code>needsReview</code> indicators for unknowns</li> <li>Risk R4 (Endpoint Differences): Use compatibility mapping layer to avoid breaking changes in UI</li> </ul>"},{"location":"implementation/USER-INTERFACE/phase-1-technical-spec/#13-future-considerations","title":"13. Future Considerations","text":"<ul> <li>Extensibility: Global state management; caching</li> <li>Migration Path: SSR/SSG if needed; route-level code-splitting</li> <li>Deprecation Strategy: Version UI models and components</li> </ul>"}]}